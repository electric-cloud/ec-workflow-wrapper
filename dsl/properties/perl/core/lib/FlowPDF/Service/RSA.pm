# WARNING
# Do not edit this file manually. Your changes will be overwritten with next FlowPDF update.
# WARNING

=pod

 Below are located Pure Perl dependencies for RSA signing.
  * Crypt::Perl::RSA with non-core dependecies
  * Math::BigInt (v1.999811).

  This Math::BigInt version should be included because some methods (e.g. bge() and bne() are not implemented in EC package)

  Modifications for original files:
   - Removed all library files from Crypt::Perl that was not required (simply deleted files one by one with a simple script)
   - Concatenated everything (except Bytes::Random::Secure::Tiny) to a single file
   - All 'use' are replaced with ->import() (because everything is located in a single file)
   - Added sign_RS1() signing method to Crypt::Perl::RSA::PrivateKey
   - Math::BigInt::Calc method api_version() was changed to _api_version() with corresponding places it was used
   - Patched Crypt::Format der2pem with string below to support keys passed without newlines
         $pem=~s<\s?-{5}(?:BEGIN|END)\s[A-Z\s]+-{5}\s?><>s;
   - Changed non-ASCII symbols (probably got there because of copying the code from browser's window)

  All concatenated modules was "packed" with
    $ perltidy -b -dp -dac --mangle dsl/properties/lib/EC/OAuthDependencies/RSA.pm

=cut

package Convert::ASN1;
{$Convert::ASN1::VERSION='0.27';
}use 5.004;
use strict;
use vars qw($VERSION @ISA @EXPORT_OK %EXPORT_TAGS @opParts @opName $AUTOLOAD);
use Exporter;
use constant CHECK_UTF8=>$]>5.007;
BEGIN{local$SIG{__DIE__};
eval{require bytes and 'bytes'->import};
if(CHECK_UTF8){require Encode;
require utf8;}@ISA=qw(Exporter);
%EXPORT_TAGS=(io=>[qw(asn_recv asn_send asn_read asn_write asn_get asn_ready)],debug=>[qw(asn_dump asn_hexdump)],const=>[qw(ASN_BOOLEAN ASN_INTEGER ASN_BIT_STR ASN_OCTET_STR
  ASN_NULL ASN_OBJECT_ID ASN_REAL ASN_ENUMERATED
  ASN_SEQUENCE ASN_SET ASN_PRINT_STR ASN_IA5_STR
  ASN_UTC_TIME ASN_GENERAL_TIME ASN_RELATIVE_OID
  ASN_UNIVERSAL ASN_APPLICATION ASN_CONTEXT ASN_PRIVATE
  ASN_PRIMITIVE ASN_CONSTRUCTOR ASN_LONG_LEN ASN_EXTENSION_ID ASN_BIT)],tag=>[qw(asn_tag asn_decode_tag2 asn_decode_tag asn_encode_tag asn_decode_length asn_encode_length)]);
@EXPORT_OK=map{@$_}values%EXPORT_TAGS;
$EXPORT_TAGS{all}=\@EXPORT_OK;
@opParts=qw(
  cTAG cTYPE cVAR cLOOP cOPT cEXT cCHILD cDEFINE
);
@opName=qw(
  opUNKNOWN opBOOLEAN opINTEGER opBITSTR opSTRING opNULL opOBJID opREAL
  opSEQUENCE opEXPLICIT opSET opUTIME opGTIME opUTF8 opANY opCHOICE opROID opBCD
  opEXTENSIONS
);
foreach my $l(\@opParts,\@opName){my$i=0;
foreach my $name(@$l){my$j=$i++;
no strict 'refs';
*{__PACKAGE__.'::'.$name}=sub (){$j}}}}sub _internal_syms{my$pkg=caller;
no strict 'refs';
for my $sub(@opParts,@opName,'dump_op'){*{$pkg.'::'.$sub}=\&{__PACKAGE__.'::'.$sub};}}sub ASN_BOOLEAN (){0x01}sub ASN_INTEGER (){0x02}sub ASN_BIT_STR (){0x03}sub ASN_OCTET_STR (){0x04}sub ASN_NULL (){0x05}sub ASN_OBJECT_ID (){0x06}sub ASN_REAL (){0x09}sub ASN_ENUMERATED (){0x0A}sub ASN_RELATIVE_OID (){0x0D}sub ASN_SEQUENCE (){0x10}sub ASN_SET (){0x11}sub ASN_PRINT_STR (){0x13}sub ASN_IA5_STR (){0x16}sub ASN_UTC_TIME (){0x17}sub ASN_GENERAL_TIME (){0x18}sub ASN_UNIVERSAL (){0x00}sub ASN_APPLICATION (){0x40}sub ASN_CONTEXT (){0x80}sub ASN_PRIVATE (){0xC0}sub ASN_PRIMITIVE (){0x00}sub ASN_CONSTRUCTOR (){0x20}sub ASN_LONG_LEN (){0x80}sub ASN_EXTENSION_ID (){0x1F}sub ASN_BIT (){0x80}sub new{my$pkg=shift;
my$self=bless{},$pkg;
$self->configure(@_);
$self;}sub configure{my$self=shift;
my%opt=@_;
$self->{options}->{encoding}=uc($opt{encoding}||'BER');
unless($self->{options}->{encoding}=~/^[BD]ER$/){require Carp;
Carp::croak("Unsupported encoding format '$opt{encoding}'");}$self->{options}->{tagdefault}=uc($opt{tagdefault}||'IMPLICIT');
unless($self->{options}->{tagdefault}=~/^(?:EXPLICIT|IMPLICIT)$/){require Carp;
Carp::croak("Default tagging must be EXPLICIT/IMPLICIT. Not $opt{tagdefault}");}for my $type(qw(encode decode)){if(exists$opt{$type}){while(my($what,$value)=each%{$opt{$type}}){$self->{options}->{"${type}_${what}"}=$value;}}}}sub find{my$self=shift;
my$what=shift;
return unless exists$self->{tree}->{$what};
my%new=%$self;
$new{script}=$new{tree}->{$what};
bless\%new,ref($self);}sub prepare{my$self=shift;
my$asn=shift;
Convert::ASN1::parser->import('parse');
$self=$self->new unless ref($self);
my$tree;
if(ref($asn)eq 'GLOB'){local$/=undef;
my$txt=<$asn>;
$tree=Convert::ASN1::parser::parse($txt,$self->{options}->{tagdefault});}else{$tree=Convert::ASN1::parser::parse($asn,$self->{options}->{tagdefault});}unless($tree){$self->{error}=$@;
return;}$self->{tree}=_pack_struct($tree);
$self->{script}=(values%$tree)[0];
$self;}sub prepare_file{my$self=shift;
my$asnp=shift;
local*ASN;
open(ASN,$asnp)or do{$self->{error}=$@;
return;};
my$ret=$self->prepare(\*ASN);
close(ASN);
$ret;}sub registeroid{my$self=shift;
my$oid=shift;
my$handler=shift;
$self->{options}->{oidtable}->{$oid}=$handler;
$self->{oidtable}->{$oid}=$handler;}sub registertype{my$self=shift;
my$def=shift;
my$type=shift;
my$handler=shift;
$self->{options}->{handlers}->{$def}->{$type}=$handler;}sub _pack_struct{$_[0]}sub _unpack_struct{$_[0]}sub encode{my$self=shift;
my$stash=@_==1?shift:{@_};
my$buf='';
local$SIG{__DIE__};
eval{_encode($self->{options},$self->{script},$stash,[],$buf)}or do{$self->{error}=$@;
undef;}}sub asn_encode_tag{$_[0]>>8?$_[0]&0x8000?$_[0]&0x800000?pack("V",$_[0]):substr(pack("V",$_[0]),0,3):pack("v",$_[0]):pack("C",$_[0]);}sub asn_encode_length{if($_[0]>>7){my$lenlen=&num_length;
return pack("Ca*",$lenlen|0x80,substr(pack("N",$_[0]),-$lenlen));}return pack("C",$_[0]);}sub decode{my$self=shift;
my$ret;
local$SIG{__DIE__};
eval{my(%stash,$result);
my$script=$self->{script};
my$stash=\$result;
while($script){my$child=$script->[0]or last;
if(@$script>1 or defined$child->[cVAR]){$result=$stash=\%stash;
last;}last if$child->[cTYPE]==opCHOICE or$child->[cLOOP];
$script=$child->[cCHILD];}_decode($self->{options},$self->{script},$stash,0,length$_[0],undef,{},$_[0]);
$ret=$result;
1;}or$self->{'error'}=$@||'Unknown error';
$ret;}sub asn_decode_length{return unless length$_[0];
my$len=unpack("C",$_[0]);
if($len&0x80){$len&=0x7f or return(1,-1);
return if$len>=length$_[0];
return(1+$len,unpack("N","\0" x(4-$len).substr($_[0],1,$len)));}return(1,$len);}sub asn_decode_tag{return unless length$_[0];
my$tag=unpack("C",$_[0]);
my$n=1;
if(($tag&0x1f)==0x1f){my$b;
do{return if$n>=length$_[0];
$b=unpack("C",substr($_[0],$n,1));
$tag|=$b <<(8*$n++);}while($b&0x80);}($n,$tag);}sub asn_decode_tag2{return unless length$_[0];
my$tag=unpack("C",$_[0]);
my$num=$tag&0x1f;
my$len=1;
if($num==0x1f){$num=0;
my$b;
do{return if$len>=length$_[0];
$b=unpack("C",substr($_[0],$len++,1));
$num=($num <<7)+($b&0x7f);}while($b&0x80);}($len,$tag,$num);}sub num_length{$_[0]>>8?$_[0]>>16?$_[0]>>24?4:3:2:1;}sub i2osp{my($num,$biclass)=@_;
eval"use $biclass";
$num=$biclass->new($num);
my$neg=$num<0 and$num=abs($num+1);
my$base=$biclass->new(256);
my$result='';
while($num!=0){my$r=$num%$base;
$num=($num-$r)/$base;
$result.=pack("C",$r);}$result^=pack("C",255)x length($result)if$neg;
return scalar reverse$result;}sub os2ip{my($os,$biclass)=@_;
eval"require $biclass";
my$base=$biclass->new(256);
my$result=$biclass->new(0);
my$neg=unpack("C",$os)>=0x80 and$os^=pack("C",255)x length($os);
for(unpack("C*",$os)){$result=($result*$base)+$_;}return$neg?($result+1)*-1:$result;}sub asn_tag{my($class,$value)=@_;
die sprintf"Bad tag class 0x%x",$class if$class&~0xe0;
unless($value&~0x1f or$value==0x1f){return(($class&0xe0)|$value);}die sprintf"Tag value 0x%08x too big\n",$value if$value&0xffe00000;
$class=($class|0x1f)&0xff;
my@t=($value&0x7f);
unshift@t,(0x80|($value&0x7f))while$value>>=7;
unpack("V",pack("C4",$class,@t,0,0));}Convert::ASN1::parser->import();
BEGIN{unless(CHECK_UTF8){local$SIG{__DIE__};
eval{require bytes}and 'bytes'->import;}}my@encode=(sub{die"internal error\n"},\&_enc_boolean,\&_enc_integer,\&_enc_bitstring,\&_enc_string,\&_enc_null,\&_enc_object_id,\&_enc_real,\&_enc_sequence,\&_enc_sequence,\&_enc_sequence,\&_enc_time,\&_enc_time,\&_enc_utf8,\&_enc_any,\&_enc_choice,\&_enc_object_id,\&_enc_bcd,);
sub _encode{my($optn,$ops,$stash,$path)=@_;
my$var;
foreach my $op(@{$ops}){next if$op->[cTYPE]==opEXTENSIONS;
if(defined(my$opt=$op->[cOPT])){next unless defined$stash->{$opt};}if(defined($var=$op->[cVAR])){push@$path,$var;
require Carp,Carp::croak(join(".",@$path)," is undefined")unless defined$stash->{$var};}$_[4].=$op->[cTAG];
&{$encode[$op->[cTYPE]]}($optn,$op,(UNIVERSAL::isa($stash,'HASH')?($stash,defined($var)?$stash->{$var}:undef):({},$stash)),$_[4],$op->[cLOOP],$path,);
pop@$path if defined$var;}$_[4];}sub _enc_boolean{$_[4].=pack("CC",1,$_[3]?0xff:0);}sub _enc_integer{if(abs($_[3])>=2**31){my$os=i2osp($_[3],ref($_[3])||$_[0]->{encode_bigint}||'Math::BigInt');
my$len=length$os;
my$msb=(vec($os,0,8)&0x80)?0:255;
$len++,$os=pack("C",$msb).$os if$msb xor$_[3]>0;
$_[4].=asn_encode_length($len);
$_[4].=$os;}else{my$val=int($_[3]);
my$neg=($val<0);
my$len=num_length($neg?~$val:$val);
my$msb=$val&(0x80 <<(($len-1)*8));
$len++ if$neg?!$msb:$msb;
$_[4].=asn_encode_length($len);
$_[4].=substr(pack("N",$val),-$len);}}sub _enc_bitstring{my$vref=ref($_[3])?\($_[3]->[0]):\$_[3];
if(CHECK_UTF8 and Encode::is_utf8($$vref)){utf8::encode(my$tmp=$$vref);
$vref=\$tmp;}if(ref($_[3])){my$less=(8-($_[3]->[1]&7))&7;
my$len=($_[3]->[1]+7)>>3;
$_[4].=asn_encode_length(1+$len);
$_[4].=pack("C",$less);
$_[4].=substr($$vref,0,$len);
if($less&&$len){substr($_[4],-1)&=pack("C",(0xff <<$less)&0xff);}}else{$_[4].=asn_encode_length(1+length$$vref);
$_[4].=pack("C",0);
$_[4].=$$vref;}}sub _enc_string{if(CHECK_UTF8 and Encode::is_utf8($_[3])){utf8::encode(my$tmp=$_[3]);
$_[4].=asn_encode_length(length$tmp);
$_[4].=$tmp;}else{$_[4].=asn_encode_length(length$_[3]);
$_[4].=$_[3];}}sub _enc_null{$_[4].=pack("C",0);}sub _enc_object_id{my@data=($_[3]=~/(\d+)/g);
if($_[1]->[cTYPE]==opOBJID){if(@data<2){@data=(0);}else{my$first=$data[1]+($data[0]*40);
splice(@data,0,2,$first);}}my$l=length$_[4];
$_[4].=pack("cw*",0,@data);
substr($_[4],$l,1)=asn_encode_length(length($_[4])-$l-1);}sub _enc_real{unless($_[3]){$_[4].=pack("C",0);
return;}require POSIX;
if($_[3]>=POSIX::HUGE_VAL()){$_[4].=pack("C*",0x01,0x40);
return;}if($_[3]<=-POSIX::HUGE_VAL()){$_[4].=pack("C*",0x01,0x41);
return;}if(exists$_[0]->{'encode_real'}&&$_[0]->{'encode_real'}ne 'binary'){my$tmp=sprintf("%g",$_[3]);
$_[4].=asn_encode_length(1+length$tmp);
$_[4].=pack("C",1);
$_[4].=$tmp;
return;}my$first=0x80;
my($mantissa,$exponent)=POSIX::frexp($_[3]);
if($mantissa<0.0){$mantissa=-$mantissa;
$first|=0x40;}my($eMant,$eExp);
while($mantissa>0.0){($mantissa,my$int)=POSIX::modf($mantissa*(1 <<8));
$eMant.=pack("C",$int);}$exponent-=8*length$eMant;
_enc_integer(undef,undef,undef,$exponent,$eExp);
if(5>length$eExp){$eExp=~s/\A.//s;
$first|=length($eExp)-1;}else{$first|=0x3;}$_[4].=asn_encode_length(1+length($eMant)+length($eExp));
$_[4].=pack("C",$first);
$_[4].=$eExp;
$_[4].=$eMant;}sub _enc_sequence{if(my$ops=$_[1]->[cCHILD]){my$l=length$_[4];
$_[4].="\0\0";
if(defined$_[5]){my$op=$ops->[0];
my$enc=$encode[$op->[cTYPE]];
my$tag=$op->[cTAG];
my$loop=$op->[cLOOP];
push@{$_[6]},-1;
foreach my $var(@{$_[3]}){$_[6]->[-1]++;
$_[4].=$tag;
&{$enc}($_[0],$op,$_[2],$var,$_[4],$loop,$_[6],);}pop@{$_[6]};}else{_encode($_[0],$_[1]->[cCHILD],defined($_[3])?$_[3]:$_[2],$_[6],$_[4]);}substr($_[4],$l,2)=asn_encode_length(length($_[4])-$l-2);}else{$_[4].=asn_encode_length(length$_[3]);
$_[4].=$_[3];}}my%_enc_time_opt=(utctime=>1,withzone=>0,raw=>2);
sub _enc_time{my$mode=$_enc_time_opt{$_[0]->{'encode_time'}||''}||0;
if($mode==2){$_[4].=asn_encode_length(length$_[3]);
$_[4].=$_[3];
return;}my$time;
my@time;
my$offset;
my$isgen=$_[1]->[cTYPE]==opGTIME;
if(ref($_[3])){$offset=int($_[3]->[1]/60);
$time=$_[3]->[0]+$_[3]->[1];}elsif($mode==0){if(exists$_[0]->{'encode_timezone'}){$offset=int($_[0]->{'encode_timezone'}/60);
$time=$_[3]+$_[0]->{'encode_timezone'};}else{@time=localtime($_[3]);
my@g=gmtime($_[3]);
$offset=($time[1]-$g[1])+($time[2]-$g[2])*60;
$time=$_[3]+$offset*60;}}else{$time=$_[3];}@time=gmtime($time);
$time[4]+=1;
$time[5]=$isgen?($time[5]+1900):($time[5]%100);
my$tmp=sprintf("%02d" x 6,@time[5,4,3,2,1,0]);
if($isgen){my$sp=sprintf("%.03f",$time);
$tmp.=substr($sp,-4)unless$sp=~/\.000$/;}$tmp.=$offset?sprintf("%+03d%02d",$offset/60,abs($offset%60)):'Z';
$_[4].=asn_encode_length(length$tmp);
$_[4].=$tmp;}sub _enc_utf8{if(CHECK_UTF8){my$tmp=$_[3];
utf8::upgrade($tmp)unless Encode::is_utf8($tmp);
utf8::encode($tmp);
$_[4].=asn_encode_length(length$tmp);
$_[4].=$tmp;}else{$_[4].=asn_encode_length(length$_[3]);
$_[4].=$_[3];}}sub _enc_any{my$handler;
if($_[1]->[cDEFINE]&&$_[2]->{$_[1]->[cDEFINE]}){$handler=$_[0]->{oidtable}->{$_[2]->{$_[1]->[cDEFINE]}};
$handler=$_[0]->{handlers}->{$_[1]->[cVAR]}->{$_[2]->{$_[1]->[cDEFINE]}}unless$handler;}if($handler){$_[4].=$handler->encode($_[3]);}else{$_[4].=$_[3];}}sub _enc_choice{my$stash=defined($_[3])?$_[3]:$_[2];
for my $op(@{$_[1]->[cCHILD]}){next if$op->[cTYPE]==opEXTENSIONS;
my$var=defined$op->[cVAR]?$op->[cVAR]:$op->[cCHILD]->[0]->[cVAR];
if(exists$stash->{$var}){push@{$_[6]},$var;
_encode($_[0],[$op],$stash,$_[6],$_[4]);
pop@{$_[6]};
return;}}require Carp;
Carp::croak("No value found for CHOICE ".join(".",@{$_[6]}));}sub _enc_bcd{my$str=("$_[3]"=~/^(\d+)/)?$1:"";
$str.="F" if length($str)&1;
$_[4].=asn_encode_length(length($str)/2);
$_[4].=pack("H*",$str);}BEGIN{local$SIG{__DIE__};
eval{require bytes and 'bytes'->import};}my@decode=(sub{die"internal error\n"},\&_dec_boolean,\&_dec_integer,\&_dec_bitstring,\&_dec_string,\&_dec_null,\&_dec_object_id,\&_dec_real,\&_dec_sequence,\&_dec_explicit,\&_dec_set,\&_dec_time,\&_dec_time,\&_dec_utf8,undef,undef,\&_dec_object_id,\&_dec_bcd,);
my@ctr;
@ctr[opBITSTR,opSTRING,opUTF8]=(\&_ctr_bitstring,\&_ctr_string,\&_ctr_string);
sub _decode{my($optn,$ops,$stash,$pos,$end,$seqof,$larr)=@_;
my$idx=0;
foreach my $buf($_[-1]){OP:
foreach my $op(@{$ops}){my$var=$op->[cVAR];
if(length$op->[cTAG]){TAGLOOP:{my($tag,$len,$npos,$indef)=_decode_tl($buf,$pos,$end,$larr)or do{next OP if$pos==$end and($seqof||defined$op->[cEXT]);
die"decode error";};
if($tag eq$op->[cTAG]){&{$decode[$op->[cTYPE]]}($optn,$op,$stash,($seqof?$seqof->[$idx++]:defined($var)?$stash->{$var}:ref($stash)eq 'SCALAR'?$$stash:1),$buf,$npos,$len,$larr);
$pos=$npos+$len+$indef;
redo TAGLOOP if$seqof&&$pos<$end;
next OP;}if($tag eq($op->[cTAG]|pack("C",ASN_CONSTRUCTOR))and my$ctr=$ctr[$op->[cTYPE]]){_decode($optn,[$op],undef,$npos,$npos+$len,(\my@ctrlist),$larr,$buf,);
($seqof?$seqof->[$idx++]:defined($var)?$stash->{$var}:ref($stash)eq 'SCALAR'?$$stash:undef)=&{$ctr}(@ctrlist);
$pos=$npos+$len+$indef;
redo TAGLOOP if$seqof&&$pos<$end;
next OP;}if($seqof||defined$op->[cEXT]){next OP;}die"decode error ".unpack("H*",$tag)."<=>".unpack("H*",$op->[cTAG])," ",$pos," ",$op->[cTYPE]," ",$op->[cVAR]||'';}}else{if($op->[cTYPE]==opANY){ANYLOOP:{my($tag,$len,$npos,$indef)=_decode_tl($buf,$pos,$end,$larr)or do{next OP if$pos==$end and($seqof||defined$op->[cEXT]);
die"decode error";};
$len+=$npos-$pos+$indef;
my$handler;
if($op->[cDEFINE]){$handler=$optn->{oidtable}&&$optn->{oidtable}->{$stash->{$op->[cDEFINE]}};
$handler||=$optn->{handlers}->{$op->[cVAR]}->{$stash->{$op->[cDEFINE]}};}($seqof?$seqof->[$idx++]:ref($stash)eq 'SCALAR'?$$stash:$stash->{$var})=$handler?$handler->decode(substr($buf,$pos,$len)):substr($buf,$pos,$len);
$pos+=$len;
redo ANYLOOP if$seqof&&$pos<$end;}}elsif($op->[cTYPE]==opCHOICE){CHOICELOOP:{my($tag,$len,$npos,$indef)=_decode_tl($buf,$pos,$end,$larr)or do{next OP if$pos==$end and($seqof||defined$op->[cEXT]);
die"decode error";};
my$extensions;
foreach my $cop(@{$op->[cCHILD]}){if($tag eq$cop->[cTAG]){my$nstash=$seqof?($seqof->[$idx++]={}):defined($var)?($stash->{$var}={}):ref($stash)eq 'SCALAR'?($$stash={}):$stash;
&{$decode[$cop->[cTYPE]]}($optn,$cop,$nstash,($cop->[cVAR]?$nstash->{$cop->[cVAR]}:undef),$buf,$npos,$len,$larr,);
$pos=$npos+$len+$indef;
redo CHOICELOOP if$seqof&&$pos<$end;
next OP;}if($cop->[cTYPE]==opEXTENSIONS){$extensions=1;
next;}unless(length$cop->[cTAG]){eval{_decode($optn,[$cop],(\my%tmp_stash),$pos,$npos+$len+$indef,undef,$larr,$buf,);
my$nstash=$seqof?($seqof->[$idx++]={}):defined($var)?($stash->{$var}={}):ref($stash)eq 'SCALAR'?($$stash={}):$stash;
@{$nstash}{keys%tmp_stash}=values%tmp_stash;}or next;
$pos=$npos+$len+$indef;
redo CHOICELOOP if$seqof&&$pos<$end;
next OP;}if($tag eq($cop->[cTAG]|pack("C",ASN_CONSTRUCTOR))and my$ctr=$ctr[$cop->[cTYPE]]){my$nstash=$seqof?($seqof->[$idx++]={}):defined($var)?($stash->{$var}={}):ref($stash)eq 'SCALAR'?($$stash={}):$stash;
_decode($optn,[$cop],undef,$npos,$npos+$len,(\my@ctrlist),$larr,$buf,);
$nstash->{$cop->[cVAR]}=&{$ctr}(@ctrlist);
$pos=$npos+$len+$indef;
redo CHOICELOOP if$seqof&&$pos<$end;
next OP;}}if($pos<$end&&$extensions){$pos=$npos+$len+$indef;
redo CHOICELOOP if$seqof&&$pos<$end;
next OP;}}die"decode error" unless$op->[cEXT];}elsif($op->[cTYPE]==opEXTENSIONS){$pos=$end;}else{die"this point should never be reached";}}}}die"decode error $pos $end" unless$pos==$end;}sub _dec_boolean{$_[3]=unpack("C",substr($_[4],$_[5],1))?1:0;
1;}sub _dec_integer{my$buf=substr($_[4],$_[5],$_[6]);
my$tmp=unpack("C",$buf)&0x80?pack("C",255):pack("C",0);
if($_[6]>4){$_[3]=os2ip($buf,$_[0]->{decode_bigint}||'Math::BigInt');}else{$_[3]=unpack("l",pack("l",unpack("N",$tmp x(4-$_[6]).$buf)));}1;}sub _dec_bitstring{$_[3]=[substr($_[4],$_[5]+1,$_[6]-1),($_[6]-1)*8-unpack("C",substr($_[4],$_[5],1))];
1;}sub _dec_string{$_[3]=substr($_[4],$_[5],$_[6]);
1;}sub _dec_null{$_[3]=exists($_[0]->{decode_null})?$_[0]->{decode_null}:1;
1;}sub _dec_object_id{my@data=unpack("w*",substr($_[4],$_[5],$_[6]));
if($_[1]->[cTYPE]==opOBJID and@data>1){if($data[0]<40){splice(@data,0,1,0,$data[0]);}elsif($data[0]<80){splice(@data,0,1,1,$data[0]-40);}else{splice(@data,0,1,2,$data[0]-80);}}$_[3]=join(".",@data);
1;}my@_dec_real_base=(2,8,16);
sub _dec_real{$_[3]=0.0,return unless$_[6];
my$first=unpack("C",substr($_[4],$_[5],1));
if($first&0x80){require POSIX;
my$exp;
my$expLen=$first&0x3;
my$estart=$_[5]+1;
if($expLen==3){$estart++;
$expLen=unpack("C",substr($_[4],$_[5]+1,1));}else{$expLen++;}_dec_integer(undef,undef,undef,$exp,$_[4],$estart,$expLen);
my$mant=0.0;
for(reverse unpack("C*",substr($_[4],$estart+$expLen,$_[6]-1-$expLen))){$exp+=8,$mant=(($mant+$_)/256);}$mant*=1 <<(($first>>2)&0x3);
$mant=-$mant if$first&0x40;
$_[3]=$mant*POSIX::pow($_dec_real_base[($first>>4)&0x3],$exp);
return;}elsif($first&0x40){$_[3]=POSIX::HUGE_VAL(),return if$first==0x40;
$_[3]=-POSIX::HUGE_VAL(),return if$first==0x41;}elsif(substr($_[4],$_[5],$_[6])=~/^.([-+]?)0*(\d+(?:\.\d+(?:[Ee][-+]?\d+)?)?)$/s){$_[3]=eval"$1$2";
return;}die"REAL decode error\n";}sub _dec_explicit{local$_[1]->[cCHILD]->[0]->[cVAR]=$_[1]->[cVAR]unless$_[1]->[cCHILD]->[0]->[cVAR];
_decode($_[0],$_[1]->[cCHILD],$_[2],$_[5],$_[5]+$_[6],undef,$_[7],$_[4],);
1;}sub _dec_sequence{if(defined(my$ch=$_[1]->[cCHILD])){_decode($_[0],$ch,(defined($_[3])||$_[1]->[cLOOP])?$_[2]:($_[3]={}),$_[5],$_[5]+$_[6],$_[1]->[cLOOP]&&($_[3]=[]),$_[7],$_[4],);}else{$_[3]=substr($_[4],$_[5],$_[6]);}1;}sub _dec_set{my$ch=$_[1]->[cCHILD];
goto&_dec_sequence if$_[1]->[cLOOP]or!defined($ch);
my($optn,$pos,$larr)=@_[0,5,7];
my$stash=defined($_[3])?$_[2]:($_[3]={});
my$end=$pos+$_[6];
my@done;
my$extensions;
while($pos<$end){my($tag,$len,$npos,$indef)=_decode_tl($_[4],$pos,$end,$larr)or die"decode error";
my($idx,$any,$done)=(-1);
SET_OP:
foreach my $op(@$ch){$idx++;
if(length($op->[cTAG])){if($tag eq$op->[cTAG]){my$var=$op->[cVAR];
&{$decode[$op->[cTYPE]]}($optn,$op,$stash,(defined($var)?$stash->{$var}:1),$_[4],$npos,$len,$larr,);
$done=$idx;
last SET_OP;}if($tag eq($op->[cTAG]|pack("C",ASN_CONSTRUCTOR))and my$ctr=$ctr[$op->[cTYPE]]){_decode($optn,[$op],undef,$npos,$npos+$len,(\my@ctrlist),$larr,$_[4],);
$stash->{$op->[cVAR]}=&{$ctr}(@ctrlist)if defined$op->[cVAR];
$done=$idx;
last SET_OP;}next SET_OP;}elsif($op->[cTYPE]==opANY){$any=$idx;}elsif($op->[cTYPE]==opCHOICE){my$var=$op->[cVAR];
foreach my $cop(@{$op->[cCHILD]}){if($tag eq$cop->[cTAG]){my$nstash=defined($var)?($stash->{$var}={}):$stash;
&{$decode[$cop->[cTYPE]]}($optn,$cop,$nstash,$nstash->{$cop->[cVAR]},$_[4],$npos,$len,$larr,);
$done=$idx;
last SET_OP;}if($tag eq($cop->[cTAG]|pack("C",ASN_CONSTRUCTOR))and my$ctr=$ctr[$cop->[cTYPE]]){my$nstash=defined($var)?($stash->{$var}={}):$stash;
_decode($optn,[$cop],undef,$npos,$npos+$len,(\my@ctrlist),$larr,$_[4],);
$nstash->{$cop->[cVAR]}=&{$ctr}(@ctrlist);
$done=$idx;
last SET_OP;}}}elsif($op->[cTYPE]==opEXTENSIONS){$extensions=$idx;}else{die"internal error";}}if(!defined($done)and defined($any)){my$var=$ch->[$any]->[cVAR];
$stash->{$var}=substr($_[4],$pos,$len+$npos-$pos)if defined$var;
$done=$any;}if(!defined($done)&&defined($extensions)){$done=$extensions;}die"decode error" if!defined($done)or$done[$done]++;
$pos=$npos+$len+$indef;}die"decode error" unless$end==$pos;
foreach my $idx(0..$#{$ch}){die"decode error" unless$done[$idx]or$ch->[$idx]->[cEXT]or$ch->[$idx]->[cTYPE]==opEXTENSIONS;}1;}my%_dec_time_opt=(unixtime=>0,withzone=>1,raw=>2);
sub _dec_time{my$mode=$_dec_time_opt{$_[0]->{'decode_time'}||''}||0;
if($mode==2 or$_[6]==0){$_[3]=substr($_[4],$_[5],$_[6]);
return;}my@bits=(substr($_[4],$_[5],$_[6])=~/^((?:\d\d)?\d\d)(\d\d)(\d\d)(\d\d)(\d\d)(\d\d)((?:\.\d{1,3})?)(([-+])(\d\d)(\d\d)|Z)/)or die"bad time format";
if($bits[0]<100){$bits[0]+=100 if$bits[0]<50;}else{$bits[0]-=1900;}$bits[1]-=1;
require Time::Local;
my$time=Time::Local::timegm(@bits[5,4,3,2,1,0]);
$time+=$bits[6]if length$bits[6];
my$offset=0;
if($bits[7]ne 'Z'){$offset=$bits[9]*3600+$bits[10]*60;
$offset=-$offset if$bits[8]eq '-';
$time-=$offset;}$_[3]=$mode?[$time,$offset]:$time;}sub _dec_utf8{BEGIN{unless(CHECK_UTF8){local$SIG{__DIE__};
eval{require bytes}and 'bytes'->unimport;
eval{require utf8}and 'utf8'->import;}}if(CHECK_UTF8){$_[3]=Encode::decode('utf8',substr($_[4],$_[5],$_[6]));}else{$_[3]=(substr($_[4],$_[5],$_[6])=~/(.*)/s)[0];}1;}sub _decode_tl{my($pos,$end,$larr)=@_[1,2,3];
return if$pos>=$end;
my$indef=0;
my$tag=substr($_[0],$pos++,1);
if((unpack("C",$tag)&0x1f)==0x1f){my$b;
my$n=1;
do{return if$pos>=$end;
$tag.=substr($_[0],$pos++,1);
$b=ord substr($tag,-1);}while($b&0x80);}return if$pos>=$end;
my$len=ord substr($_[0],$pos++,1);
if($len&0x80){$len&=0x7f;
if($len){return if$pos+$len>$end;
my$padding=$len<4?"\0" x(4-$len):"";
($len,$pos)=(unpack("N",$padding.substr($_[0],$pos,$len)),$pos+$len);}else{unless(exists$larr->{$pos}){_scan_indef($_[0],$pos,$end,$larr)or return;}$indef=2;
$len=$larr->{$pos};}}return if$pos+$len+$indef>$end;
($tag,$len,$pos,$indef);}sub _scan_indef{my($pos,$end,$larr)=@_[1,2,3];
my@depth=($pos);
while(@depth){return if$pos+2>$end;
if(substr($_[0],$pos,2)eq"\0\0"){my$end=$pos;
my$stref=shift@depth;
$larr->{$stref}=$end-$stref;
$pos+=2;
next;}my$tag=substr($_[0],$pos++,1);
if((unpack("C",$tag)&0x1f)==0x1f){my$b;
do{$tag.=substr($_[0],$pos++,1);
$b=ord substr($tag,-1);}while($b&0x80);}return if$pos>=$end;
my$len=ord substr($_[0],$pos++,1);
if($len&0x80){if($len&=0x7f){return if$pos+$len>$end;
my$padding=$len<4?"\0" x(4-$len):"";
$pos+=$len+unpack("N",$padding.substr($_[0],$pos,$len));}else{unshift@depth,$pos;}}else{$pos+=$len;}}1;}sub _ctr_string{join '',@_}sub _ctr_bitstring{[join('',map{$_->[0]}@_),$_[-1]->[1]]}sub _dec_bcd{($_[3]=unpack("H*",substr($_[4],$_[5],$_[6])))=~s/[fF]$//;
1;}use Socket;
BEGIN{local$SIG{__DIE__};
eval{require bytes}and 'bytes'->import;}sub asn_recv{my$peer;
my$buf;
my$n=128;
my$pos=0;
my$depth=0;
my$len=0;
my($tmp,$tb,$lb);
MORE:
for($peer=recv($_[0],$buf,$n,MSG_PEEK);defined$peer;$peer=recv($_[0],$buf,$n <<=1,MSG_PEEK)){if($depth){unless(2+$pos<=length$buf){next MORE if$n==length$buf;
last MORE;}if(substr($buf,$pos,2)eq"\0\0"){unless(--$depth){$len=$pos+2;
last MORE;}}}($tb,$tmp)=asn_decode_tag(substr($buf,$pos));
unless($tb||$pos+$tb<length$buf){next MORE if$n==length$buf;
last MORE;}if(unpack("C",substr($buf,$pos+$tb,1))==0x80){$depth++;
$pos+=$tb+1;
redo MORE;}($lb,$len)=asn_decode_length(substr($buf,$pos+$tb));
if($lb){if($depth){$pos+=$tb+$lb+$len;
redo MORE;}else{$len+=$tb+$lb+$pos;
last MORE;}}}if(defined$peer){if($len>length$buf){goto error unless defined($peer=recv($_[0],$buf,$len,MSG_PEEK));
if($len>length$buf){$_[1]='';
return$peer;}}elsif($len==0){$_[1]='';
return$peer;}if($_[2]& MSG_PEEK){$_[1]=substr($buf,0,$len);}elsif(!defined($peer=recv($_[0],$_[1],$len,0))){goto error;}return$peer;}error:
$_[1]=undef;}sub asn_read{if($_[2]){if($_[2]>length$_[1]){require Carp;
Carp::carp("Offset beyond end of buffer");
return;}substr($_[1],$_[2])='';}else{$_[1]='';}my$pos=0;
my$need=0;
my$depth=0;
my$ch;
my$n;
my$e;
while(1){$need=($pos+($depth*2))||2;
while(($n=$need-length$_[1])>0){$e=sysread($_[0],$_[1],$n,length$_[1])or goto READ_ERR;}my$tch=unpack("C",substr($_[1],$pos++,1));
if(($tch&0x1f)==0x1f){my$ch;
do{$need++;
while(($n=$need-length$_[1])>0){$e=sysread($_[0],$_[1],$n,length$_[1])or goto READ_ERR;}$ch=unpack("C",substr($_[1],$pos++,1));}while($ch&0x80);}$need=$pos+1;
while(($n=$need-length$_[1])>0){$e=sysread($_[0],$_[1],$n,length$_[1])or goto READ_ERR;}my$len=unpack("C",substr($_[1],$pos++,1));
if($len&0x80){unless($len&=0x7f){$depth++;
next;}$need=$pos+$len;
while(($n=$need-length$_[1])>0){$e=sysread($_[0],$_[1],$n,length$_[1])or goto READ_ERR;}$pos+=$len+unpack("N","\0" x(4-$len).substr($_[1],$pos,$len));}elsif(!$len&&!$tch){die"Bad ASN PDU" unless$depth;
unless(--$depth){last;}}else{$pos+=$len;}last unless$depth;}while(($n=$pos-length$_[1])>0){$e=sysread($_[0],$_[1],$n,length$_[1])or goto READ_ERR;}return length$_[1];
READ_ERR:
$@=defined($e)?"Unexpected EOF":"I/O Error $!";
return undef;}sub asn_send{@_==4?send($_[0],$_[1],$_[2],$_[3]):send($_[0],$_[1],$_[2]);}sub asn_write{syswrite($_[0],$_[1],length$_[1]);}sub asn_get{my$fh=ref($_[0])?$_[0]:\($_[0]);
my$href=\%{*$fh};
$href->{'asn_buffer'}='' unless exists$href->{'asn_buffer'};
my$need=delete$href->{'asn_need'}||0;
while(1){next if$need;
my($tb,$tag)=asn_decode_tag($href->{'asn_buffer'})or next;
my($lb,$len)=asn_decode_length(substr($href->{'asn_buffer'},$tb,8))or next;
$need=$tb+$lb+$len;}continue{if($need&&$need<=length$href->{'asn_buffer'}){my$ret=substr($href->{'asn_buffer'},0,$need);
substr($href->{'asn_buffer'},0,$need)='';
return$ret;}my$get=$need>1024?$need:1024;
sysread($_[0],$href->{'asn_buffer'},$get,length$href->{'asn_buffer'})or return undef;}}sub asn_ready{my$fh=ref($_[0])?$_[0]:\($_[0]);
my$href=\%{*$fh};
return 0 unless exists$href->{'asn_buffer'};
return$href->{'asn_need'}<=length$href->{'asn_buffer'}if exists$href->{'asn_need'};
my($tb,$tag)=asn_decode_tag($href->{'asn_buffer'})or return 0;
my($lb,$len)=asn_decode_length(substr($href->{'asn_buffer'},$tb,8))or return 0;
$href->{'asn_need'}=$tb+$lb+$len;
$href->{'asn_need'}<=length$href->{'asn_buffer'};}package Crypt::Format;
use strict;
use warnings;
our$VERSION='0.09';
our$BASE64_MODULE='MIME::Base64';
sub der2pem{my($der_r,$whatsit)=(\$_[0],$_[1]);
die"Missing object type!" if!$whatsit;
my$pem=_do_base64('encode',$$der_r);
my$line_sep=substr($pem,-1);
substr($pem,0,0,"-----BEGIN $whatsit-----$line_sep");
substr($pem,length($pem),0,"-----END $whatsit-----");
return$pem;}sub pem2der{my($pem)=@_;
chomp$pem;
$pem=~s<.+?[\x0d\x0a]+><>s;
$pem=~s<[\x0d\x0a]+[^\x0d\x0a]+?\z><>s;
$pem=~s<\s?-{5}(?:BEGIN|END)\s[A-Z\s]+-{5}\s?><>s;
return _do_base64('decode',$pem);}sub _do_base64{my$path="$BASE64_MODULE.pm";
$path=~s<::></>g;
_load_module($BASE64_MODULE)if!$INC{$path};
my$cr=$BASE64_MODULE->can(shift);
return$cr->(@_);}sub _load_module{local$@;
eval"use $_[0]; 1" or die;
return$_[0];}sub normalize_pem{my($pem)=@_;
$pem=~m<BEGIN ([^-]+)> or die"Invalid PEM: $pem";
return der2pem(pem2der($pem),$1);}package Crypt::Perl::ASN1;
use strict;
use warnings;
BEGIN{our@ISA='Convert::ASN1';}Crypt::Perl::BigInt->import();
Crypt::Perl::X->import();
sub new{my($class,@opts)=@_;
return$class->SUPER::new(encode=>{bigint=>'Crypt::Perl::BigInt'},decode=>{bigint=>'Crypt::Perl::BigInt'},@opts,);}sub prepare{my($self,$asn1_r)=($_[0],\$_[1]);
my$ret=$self->SUPER::prepare($$asn1_r);
if(!defined$ret){die Crypt::Perl::X::create('ASN1::Prepare',$$asn1_r,$self->{error});}return$ret;}sub find{my($self,$macro)=@_;
return$self->SUPER::find($macro)||do{die Crypt::Perl::X::create('ASN1::Find',$macro,$self->{error});};}sub encode{my($self)=shift;
return$self->SUPER::encode(@_)||do{die Crypt::Perl::X::create('ASN1::Encode',\@_,$self->{error});};}sub decode{my($self)=shift;
return$self->SUPER::decode($_[0])||do{die Crypt::Perl::X::create('ASN1::Decode',$_[0],$self->{error});};}my$_asn1_null;
sub NULL{return$_asn1_null||=Crypt::Perl::ASN1->new()->prepare('n NULL')->encode({n=>0});}1;
package Crypt::Perl::BigInt;
use strict;
use warnings;
Math::BigInt->import(try=>'GMP');
BEGIN{our@ISA='Math::BigInt';}BEGIN{*from_bytes=\&_pp_from_bytes;
*as_bytes=\&_pp_as_bytes;
$@=q<>;}Crypt::Perl::X->import();
sub _pp_from_bytes{my$class=shift;
return$class->from_hex(unpack 'H*',$_[0]);}sub _pp_as_bytes{my($self)=@_;
die Crypt::Perl::X::create('Generic',"Negatives ($self) can\'t convert to bytes!")if$self<0;
my$hex=$self->as_hex();
if(length($hex)%2){substr($hex,1,1)=q<>;}else{substr($hex,0,2)=q<>;}return pack 'H*',$hex;}sub bit_length{my($self)=@_;
return(length($self->as_bin())-2);}sub test_bit{my($self,$bit_from_least)=@_;
my$bstr=substr($self->as_bin(),2);
return 0 if$bit_from_least>=length($bstr);
return substr($bstr,-$bit_from_least-1,1);}1;
package Crypt::Perl::KeyBase;
use strict;
use warnings;
Crypt::Perl::X->import();
sub get_jwk_thumbprint{my($self,$hash_alg)=@_;
die Crypt::Perl::X::create('Generic','Need a hashing algorithm!')if!length$hash_alg;
require Digest::SHA;
my$hash_cr=($hash_alg=~m<\Asha[0-9]+\z>) && Digest::SHA->can($hash_alg)or do{die Crypt::Perl::X::create('UnknownHash',$hash_alg);};
my$jwk=$self->get_struct_for_public_jwk();
my$json=sprintf('{'.join(',',map{qq{"$_":"%s"}}$self->_JWK_THUMBPRINT_JSON_ORDER()).'}',@{$jwk}{$self->_JWK_THUMBPRINT_JSON_ORDER()},);
require MIME::Base64;
return MIME::Base64::encode_base64url($hash_cr->($json));}1;
package Crypt::Perl::PKCS8;
use strict;
use warnings;
Crypt::Perl::ASN1->import();
use constant ASN1=> <<END;
    -- FG: simplified from RFC for Convert::ASN1
    Version ::= INTEGER

    -- cf. RFC 3280 4.1.1.2
    AlgorithmIdentifier  ::=  SEQUENCE  {
        algorithm   OBJECT IDENTIFIER,
        parameters  ANY DEFINED BY algorithm OPTIONAL
    }

    -- cf. RFC 5208 appendix A
    PrivateKeyInfo ::= SEQUENCE {
        version             Version,
        privateKeyAlgorithm AlgorithmIdentifier,
        privateKey          PrivateKey
    }

    PrivateKey ::= OCTET STRING

    -- cf. RFC 3280 4.1
    SubjectPublicKeyInfo  ::=  SEQUENCE  {
        algorithm            AlgorithmIdentifier,
        subjectPublicKey     BIT STRING
    }
END
sub parse_private{my($pem_or_der)=@_;
return _asn1()->find('PrivateKeyInfo')->decode($pem_or_der);}sub parse_public{my($pem_or_der)=@_;
return _asn1()->find('SubjectPublicKeyInfo')->decode($pem_or_der);}sub _asn1{return Crypt::Perl::ASN1->new()->prepare(Crypt::Perl::PKCS8::ASN1());}1;
package Crypt::Perl::RNG;
use strict;
use warnings;
use Bytes::Random::Secure::Tiny;
my%PID_RNG;
sub _get{return$PID_RNG{$$}||=Bytes::Random::Secure::Tiny->new();}sub bytes{return _get()->bytes(@_);}sub bytes_hex{return _get()->bytes_hex(@_);}sub bit_string{my($count)=@_;
return _get()->string_from('01',$count);}1;
package Crypt::Perl::RSA::KeyBase;
use strict;
use warnings;
use base ('Class::Accessor','Crypt::Perl::KeyBase');
Module::Load->import();
Crypt::Perl::BigInt->import();
Crypt::Perl::X->import();
BEGIN{__PACKAGE__->mk_ro_accessors('modulus');
__PACKAGE__->mk_ro_accessors('publicExponent');
*N=\&modulus;
*E=\&publicExponent;}use constant _JWK_THUMBPRINT_JSON_ORDER=>qw(e kty n);
sub new{my($class,@args)=@_;
my$self=$class->SUPER::new(@args);
$self->{'publicExponent'}=Crypt::Perl::BigInt->new($self->{'publicExponent'});
return$self;}sub to_pem{my($self)=@_;
require Crypt::Format;
return Crypt::Format::der2pem($self->to_der(),$self->_PEM_HEADER());}sub size{my($self)=@_;
return length($self->modulus()->as_bin())-2;}sub modulus_byte_length{my($self)=@_;
return length$self->N()->as_bytes();}sub verify_RS256{my($self,$msg,$sig)=@_;
return$self->_verify($msg,$sig,'Digest::SHA','sha256','PKCS1_v1_5');}sub verify_RS384{my($self,$msg,$sig)=@_;
return$self->_verify($msg,$sig,'Digest::SHA','sha384','PKCS1_v1_5');}sub verify_RS512{my($self,$msg,$sig)=@_;
return$self->_verify($msg,$sig,'Digest::SHA','sha512','PKCS1_v1_5');}sub encrypt_raw{my($self,$bytes)=@_;
return Crypt::Perl::BigInt->from_bytes($bytes)->bmodpow($self->{'publicExponent'},$self->{'modulus'})->as_bytes();}sub to_der{my($self)=@_;
return$self->_to_der($self->_ASN1_MACRO());}sub algorithm_identifier{my($self)=@_;
return{algorithm=>OID_rsaEncryption(),parameters=>Crypt::Perl::ASN1::NULL(),};}use constant OID_rsaEncryption=>'1.2.840.113549.1.1.1';
sub _to_subject_public_der{my($self)=@_;
my$asn1=$self->_asn1_find('SubjectPublicKeyInfo');
return$asn1->encode({algorithm=>$self->algorithm_identifier(),subjectPublicKey=>$self->_to_der('RSAPublicKey'),});}sub get_struct_for_public_jwk{my($self)=@_;
require MIME::Base64;
return{kty=>'RSA',n=>MIME::Base64::encode_base64url($self->N()->as_bytes()),e=>MIME::Base64::encode_base64url($self->E()->as_bytes()),};}sub _asn1_find{my($self,$macro)=@_;
require Crypt::Perl::ASN1;
require Crypt::Perl::RSA::Template;
my$asn1=Crypt::Perl::ASN1->new()->prepare(Crypt::Perl::RSA::Template::get_template('INTEGER'),);
return$asn1->find($macro);}sub _to_der{my($self,$macro)=@_;
return$self->_asn1_find($macro)->encode({%$self});}sub _verify{my($self,$message,$signature,$hash_module,$hasher,$scheme)=@_;
Module::Load::load($hash_module);
my$digest=$hash_module->can($hasher)->($message);
my$y=Crypt::Perl::BigInt->from_hex(unpack 'H*',$signature);
my$x=$y->bmodpow($self->E(),$self->N());
my$octets="\0".$x->as_bytes();
if($scheme eq 'PKCS1_v1_5'){my$key_bytes_length=$self->modulus_byte_length();
if(length($octets)!=$key_bytes_length){my$err=sprintf("Invalid PKCS1_v1_5 length: %d (should be %d)",length($octets),$key_bytes_length);
die Crypt::Perl::X::create('Generic',$err);}Crypt::Perl::RSA::PKCS1_v1_5->import();
return$digest eq Crypt::Perl::RSA::PKCS1_v1_5::decode($octets,$hasher);}die Crypt::Perl::X::create('Generic',"Unknown signature scheme: \"$scheme\"");}1;
package Crypt::Perl::RSA::Parse;
use strict;
use warnings;
use Try::Tiny;
Crypt::Format->import();
Crypt::Perl::ASN1->import();
Crypt::Perl::RSA::Template->import();
Crypt::Perl::X->import();
sub _asn1{return Crypt::Perl::ASN1->new()->prepare(Crypt::Perl::RSA::Template::get_template('INTEGER'),);}sub private{my($pem_or_der)=@_;
_ensure_der($pem_or_der);
my$key_obj;
try{my$parsed=_decode_rsa($pem_or_der);
$key_obj=_new_private($parsed);}catch{my$rsa_err=$_;
try{$key_obj=private_pkcs8($pem_or_der);}catch{die Crypt::Perl::X::create('Generic',"Failed to parse as either RSA ($rsa_err) or PKCS8 ($_)");};};
return$key_obj;}sub private_pkcs8{my($pem_or_der)=@_;
_ensure_der($pem_or_der);
my$pkcs8=_decode_pkcs8($pem_or_der);
my$parsed=_decode_rsa_within_pkcs8_or_die($pkcs8);
return _new_private($parsed);}sub public{my($pem_or_der)=@_;
_ensure_der($pem_or_der);
my$key_obj;
try{my$parsed=_decode_rsa_public($pem_or_der);
$key_obj=_new_public($parsed);}catch{my$rsa_err=$_;
try{$key_obj=public_SPKI($pem_or_der);}catch{die Crypt::Perl::X::create('Generic',"Failed to parse as either RSA ($rsa_err) or SubjectPublicKeyInfo ($_)");};};
return$key_obj;}sub public_SPKI{my($pem_or_der)=@_;
_ensure_der($pem_or_der);
my$spki=_decode_spki($pem_or_der);
my$parsed=_decode_rsa_public_within_spki_or_die($spki);
return _new_public($parsed);}my%JTK_TO_NEW=qw(
  n modulus
  e publicExponent
  d privateExponent
  p prime1
  q prime2
  dp exponent1
  dq exponent2
  qi coefficient
);
sub jwk{my($hr)=@_;
my%constr_args;
require Crypt::Perl::JWK;
for my $k(keys%$hr){next if!$JTK_TO_NEW{$k};
$constr_args{$JTK_TO_NEW{$k}}=Crypt::Perl::JWK::jwk_num_to_bigint($hr->{$k});}if($hr->{'d'}){$constr_args{'version'}=0;
require Crypt::Perl::RSA::PrivateKey;
return Crypt::Perl::RSA::PrivateKey->new(\%constr_args);}require Crypt::Perl::RSA::PublicKey;
return Crypt::Perl::RSA::PublicKey->new(\%constr_args);}sub _decode_macro{my($der_r,$macro)=(\$_[0],$_[1]);
my$parser=_asn1()->find($macro);
return$parser->decode($$der_r);}sub _decode_rsa{my($der_r)=(\$_[0]);
return _decode_macro($$der_r,'RSAPrivateKey');}sub _decode_rsa_public{my($der_r)=(\$_[0]);
return _decode_macro($$der_r,'RSAPublicKey');}sub _decode_rsa_within_pkcs8_or_die{my($pkcs8_hr)=@_;
my$dec;
try{$dec=_decode_rsa($pkcs8_hr->{'privateKey'});}catch{die Crypt::Perl::X::create('Generic',"Failed to parse RSA within PKCS8: $_");};
return$dec;}sub _decode_rsa_public_within_spki_or_die{my($spki_hr)=@_;
my$dec;
try{$dec=_decode_rsa_public($spki_hr->{'subjectPublicKey'}->[0]);}catch{die Crypt::Perl::X::create('Generic',"Failed to parse RSA within SubjectPublicKeyInfo: $_");};
return$dec;}sub _decode_pkcs8{my($der_r)=(\$_[0]);
return _decode_macro($$der_r,'PrivateKeyInfo');}sub _decode_spki{my($der_r)=(\$_[0]);
return _decode_macro($$der_r,'SubjectPublicKeyInfo');}sub _new_public{my($parsed_hr)=@_;
require Crypt::Perl::RSA::PublicKey;
return Crypt::Perl::RSA::PublicKey->new($parsed_hr);}sub _new_private{my($parsed_hr)=@_;
Crypt::Perl::RSA::PrivateKey->import()unless$Crypt::Perl::RSA::PrivateKey::VERSION;
return Crypt::Perl::RSA::PrivateKey->new($parsed_hr);}sub _pem_to_der{$_[0]=Crypt::Format::pem2der(@_);
return;}sub _ensure_der{my($pem_or_der_r)=\$_[0];
if($$pem_or_der_r=~m<\A->){_pem_to_der($$pem_or_der_r);}return;}1;
package Crypt::Perl::RSA::PKCS1_v1_5;
use strict;
use warnings;
Crypt::Perl::X->import();
use constant DER_header_md2=>"\x30\x20\x30\x0c\x06\x08\x2a\x86\x48\x86\xf7\x0d\x02\x02\x05\x00\x04\x10";
use constant DER_header_md5=>"\x30\x20\x30\x0c\x06\x08\x2a\x86\x48\x86\xf7\x0d\x02\x05\x05\x00\x04\x10";
use constant DER_header_sha1=>"\x30\x21\x30\x09\x06\x05\x2b\x0e\x03\x02\x1a\x05\x00\x04\x14";
use constant DER_header_sha256=>"\x30\x31\x30\x0d\x06\x09\x60\x86\x48\x01\x65\x03\x04\x02\x01\x05\x00\x04\x20";
use constant DER_header_sha384=>"\x30\x41\x30\x0d\x06\x09\x60\x86\x48\x01\x65\x03\x04\x02\x02\x05\x00\x04\x30";
use constant DER_header_sha512=>"\x30\x51\x30\x0d\x06\x09\x60\x86\x48\x01\x65\x03\x04\x02\x03\x05\x00\x04\x40";
sub encode{my($digest,$digest_oid,$emLen)=@_;
my$encoded=_asn1_DigestInfo($digest,$digest_oid);
if($emLen<length($encoded)+11){die Crypt::Perl::X::create('Generic',sprintf"intended encoded message length (%d bytes) is too short--must be at least %d bytes",$emLen,11+length$encoded);}my$PS="\x{ff}" x($emLen-length($encoded)-3);
return"\0\1$PS\0$encoded";}sub decode{my($octets,$digest_oid)=@_;
my$hdr=_get_der_header($digest_oid);
$octets=~m<\A \x00 \x01 \xff+ \x00 \Q$hdr\E >x or do{my$err=sprintf"Invalid EMSA-PKCS1-v1_5/$digest_oid: %v02x",$octets;
die Crypt::Perl::X::create('Generic',$err);};
return substr($octets,$+[0]);}sub _get_der_header{my($oid)=@_;
return __PACKAGE__->can("DER_header_$oid")->();}sub _asn1_DigestInfo{my($digest,$oid)=@_;
return _get_der_header($oid).$digest;}1;
package Crypt::Perl::RSA::PrivateKey;
use strict;
use warnings;
BEGIN{our@ISA='Crypt::Perl::RSA::KeyBase';}Module::Load->import();
Crypt::Perl::RNG->import();
Crypt::Perl::X->import();
use constant _PEM_HEADER=>'RSA PRIVATE KEY';
use constant _ASN1_MACRO=>'RSAPrivateKey';
BEGIN{__PACKAGE__->mk_ro_accessors(qw(
  version
  publicExponent
  privateExponent
  prime1
  prime2
  exponent1
  exponent2
  coefficient
  ));
*E=\&publicExponent;
*D=\&privateExponent;
*P=\&prime1;
*Q=\&prime2;
*DP=\&exponent1;
*DQ=\&exponent2;
*QINV=\&coefficient;
*to_subject_public_der=__PACKAGE__->can('_to_subject_public_der');}sub sign_RS1{my($self,$msg)=@_;
return$self->_sign($msg,'Digest::SHA','sha1','PKCS1_v1_5');}sub sign_RS256{my($self,$msg)=@_;
return$self->_sign($msg,'Digest::SHA','sha256','PKCS1_v1_5');}sub sign_RS384{my($self,$msg)=@_;
return$self->_sign($msg,'Digest::SHA','sha384','PKCS1_v1_5');}sub sign_RS512{my($self,$msg)=@_;
return$self->_sign($msg,'Digest::SHA','sha512','PKCS1_v1_5');}sub get_public_key{my($self)=@_;
require Crypt::Perl::RSA::PublicKey;
return Crypt::Perl::RSA::PublicKey->new({modulus=>$self->{'modulus'},publicExponent=>$self->{'publicExponent'},});}sub get_struct_for_private_jwk{my($self)=@_;
require MIME::Base64;
my$jwk=$self->get_struct_for_public_jwk();
my%augment=qw(
  d D
  p P
  q Q
  dp DP
  dq DQ
  qi QINV
);
for my $k(keys%augment){my$accessor=$augment{$k};
$jwk->{$k}=MIME::Base64::encode_base64url($self->$accessor()->as_bytes());}return$jwk;}sub decrypt_raw{my($self,$x)=@_;
$x=Crypt::Perl::BigInt->from_bytes($x);
my$p=$self->P();
my$q=$self->Q();
my$p1=$p->copy()->bdec();
my$q1=$q->copy()->bdec();
my$xp=$x->copy()->bmod($p)->bmodpow($self->D()->copy()->bmod($p1),$p);
my$xq=$x->copy()->bmod($q)->bmodpow($self->D()->copy()->bmod($q1),$q);
my$diff=$xp->bsub($xq)->babs()->bmod($p)->bsub($p)->babs();
$diff->bmul($self->QINV())->bmod($p)->bmuladd($q,$xq)->as_bytes();}sub _sign{my($self,$msg,$hash_module,$hasher,$scheme)=@_;
require Digest::SHA;
my$dgst=$hash_module->can($hasher)->($msg);
my$sig;
if($scheme eq 'PKCS1_v1_5'){Crypt::Perl::RSA::PKCS1_v1_5->import();
my$sig_length=$self->modulus_byte_length();
my$eb=Crypt::Perl::RSA::PKCS1_v1_5::encode($dgst,$hasher,$sig_length,);
my$x=Crypt::Perl::BigInt->from_hex(unpack 'H*',$eb);
$sig=$self->_transform($x)->as_bytes();
substr($sig,0,0)="\0" x($sig_length-length$sig);}else{die Crypt::Perl::X::create('Generic',"Unknown RSA signature scheme: \"$scheme\"");}return$sig;}sub _transform{my($self,$x)=@_;
my$key_bytes_length=$self->modulus_byte_length();
my$r;
do{$r=Crypt::Perl::BigInt->from_hex(Crypt::Perl::RNG::bytes_hex($key_bytes_length),);}while($r->bge($self->N()))||($r->bgcd($self->N())->bne(1));
$x->bmul($r->copy()->bmodpow($self->E(),$self->N()))->bmod($self->N());
my$xp=$x->copy()->bmod($self->P())->bmodpow($self->DP(),$self->P());
my$xq=$x->copy()->bmod($self->Q())->bmodpow($self->DQ(),$self->Q());
$xp->badd($self->P())while$xp->blt($xq);
my$y=$xp->bsub($xq)->bmul($self->QINV())->bmod($self->P());
$y->bmuladd($self->Q(),$xq);
$y->bmul($r->bmodinv($self->N()));
$y->bmod($self->N());
return$y;}1;
package Crypt::Perl::RSA::Template;
use strict;
use warnings;
Crypt::Perl::PKCS8->import();
my$ASN1_TEMPLATE=q<

    FG_FAUX_INTEGER ::= <WHAT_IS_FG_FAUX_INTEGER>

    RSAPublicKey ::= SEQUENCE {
        modulus         FG_FAUX_INTEGER,  -- n
        publicExponent  FG_FAUX_INTEGER   -- e
    }

    -- FG: simplified from RFC for Convert::ASN1
    Version ::= INTEGER

    OtherPrimeInfo ::= SEQUENCE {
        prime             FG_FAUX_INTEGER,  -- ri
        exponent          FG_FAUX_INTEGER,  -- di
        coefficient       FG_FAUX_INTEGER   -- ti
    }

    -- FG: simplified from RFC for Convert::ASN1
    OtherPrimeInfos ::= SEQUENCE OF OtherPrimeInfo

    RSAPrivateKey ::= SEQUENCE {
        version           Version,
        modulus           FG_FAUX_INTEGER,  -- n
        publicExponent    INTEGER,  -- e
        privateExponent   FG_FAUX_INTEGER,  -- d
        prime1            FG_FAUX_INTEGER,  -- p
        prime2            FG_FAUX_INTEGER,  -- q
        exponent1         FG_FAUX_INTEGER,  -- d mod (p-1)
        exponent2         FG_FAUX_INTEGER,  -- d mod (q-1)
        coefficient       FG_FAUX_INTEGER,  -- (inverse of q) mod p
        otherPrimeInfos   OtherPrimeInfos OPTIONAL
    }
>.Crypt::Perl::PKCS8::ASN1();
sub get_template{my($what_is_big_fat_int)=@_;
my$template=$ASN1_TEMPLATE;
$template=~s/<WHAT_IS_FG_FAUX_INTEGER>/$what_is_big_fat_int/;
return$template;}1;
package Crypt::Perl::X;
use strict;
use warnings;
Module::Load->import();
sub create{my($type,@args)=@_;
my$x_package="Crypt::Perl::X::$type";
Module::Load::load($x_package);
return$x_package->new(@args);}package Module::Load;
$VERSION='0.32';
use strict;
use warnings;
use File::Spec ();
sub import{my$who=_who();
my$h;
shift;
{no strict 'refs';
@_ or(*{"${who}::load"}=\&load,*{"${who}::autoload"}=\&autoload,return);
map{$h->{$_}=()if defined$_}@_;
(exists$h->{none}or exists$h->{''})and shift,last;
((exists$h->{autoload}and shift,1)or(exists$h->{all}and shift))and*{"${who}::autoload"}=\&autoload;
((exists$h->{load}and shift,1)or exists$h->{all})and*{"${who}::load"}=\&load;
((exists$h->{load_remote}and shift,1)or exists$h->{all})and*{"${who}::load_remote"}=\&load_remote;
((exists$h->{autoload_remote}and shift,1)or exists$h->{all})and*{"${who}::autoload_remote"}=\&autoload_remote;}}sub load (*;@){goto&_load;}sub autoload (*;@){unshift@_,'autoimport';
goto&_load;}sub load_remote ($$;@){my($dst,$src,@exp)=@_;
eval"package $dst;Module::Load::load('$src', qw/@exp/);";
$@&&die"$@";}sub autoload_remote ($$;@){my($dst,$src,@exp)=@_;
eval"package $dst;Module::Load::autoload('$src', qw/@exp/);";
$@&&die"$@";}sub _load{my$autoimport=$_[0]eq 'autoimport' and shift;
my$mod=shift or return;
my$who=_who();
if(_is_file($mod)){require$mod;}else{LOAD:{my$err;
for my $flag(qw[1 0]){eval{if($flag){$mod->import()}else{require$mod;$mod->import()}};
$@?$err.=$@:last LOAD;}die$err if$err;}}{no strict 'refs';
my$import;
((@_ or$autoimport)and($import=$mod->can('import'))and(unshift(@_,$mod),goto&$import,return));}}sub _to_file{local$_=shift;
my$pm=shift||'';
my@parts=split/::|'/,$_,-1;
shift@parts if@parts&&!$parts[0];
my$file=$^O eq 'MSWin32'?join"/",@parts:File::Spec->catfile(@parts);
$file.='.pm' if$pm;
$file=VMS::Filespec::unixify($file)if$^O eq 'VMS';
return$file;}sub _who{(caller(1))[0]}sub _is_file{local$_=shift;
return/^\./?1:/[^\w:']/?1:undef;}package Crypt::Perl::X::Generic;
use strict;
use warnings;
our@ISA=qw(Crypt::Perl::X::Base);
package Crypt::Perl::X::Base;
use strict;
use warnings;
use Carp ();
sub new{my($class,$string,$props_hr)=@_;
$class->_check_overload();
my%attrs=$props_hr?%$props_hr:();
return bless[$string,\%attrs],$class;}sub get{my($self,$attr)=@_;
return$self->[1]->{$attr};}sub to_string{my($self)=@_;
return sprintf '%s: %s',ref($self),$self->[0];}my%_OVERLOADED;
sub _check_overload{my($class,$str)=@_;
my$eval_err=$@;
$_OVERLOADED{$class}||=eval qq{
        package $class;
        use overload (q<""> => __PACKAGE__->can('__spew'));
        1;
    };
warn if!$_OVERLOADED{$class};
$@=$eval_err;
return;}sub __spew{my($self)=@_;
my$spew=$self->to_string();
if(substr($spew,-1)ne"\n"){$spew.=Carp::longmess();}return$spew;}package Convert::ASN1::parser;
{$Convert::ASN1::parser::VERSION='0.27';}use strict;
Convert::ASN1->import(':all');
use vars qw(
  $asn $yychar $yyerrflag $yynerrs $yyn @yyss
  $yyssp $yystate @yyvs $yyvsp $yylval $yys $yym $yyval
);
BEGIN{Convert::ASN1->_internal_syms}my$yydebug=0;
my%yystate;
sub ASN_BOOLEAN (){0x01}sub ASN_INTEGER (){0x02}sub ASN_BIT_STR (){0x03}sub ASN_OCTET_STR (){0x04}sub ASN_NULL (){0x05}sub ASN_OBJECT_ID (){0x06}sub ASN_REAL (){0x09}sub ASN_ENUMERATED (){0x0A}sub ASN_RELATIVE_OID (){0x0D}sub ASN_SEQUENCE (){0x10}sub ASN_SET (){0x11}sub ASN_PRINT_STR (){0x13}sub ASN_IA5_STR (){0x16}sub ASN_UTC_TIME (){0x17}sub ASN_GENERAL_TIME (){0x18}sub ASN_UNIVERSAL (){0x00}sub ASN_APPLICATION (){0x40}sub ASN_CONTEXT (){0x80}sub ASN_PRIVATE (){0xC0}sub ASN_PRIMITIVE (){0x00}sub ASN_CONSTRUCTOR (){0x20}sub ASN_LONG_LEN (){0x80}sub ASN_EXTENSION_ID (){0x1F}sub ASN_BIT (){0x80}my%base_type=(BOOLEAN=>[asn_encode_tag(ASN_BOOLEAN),opBOOLEAN],INTEGER=>[asn_encode_tag(ASN_INTEGER),opINTEGER],BIT_STRING=>[asn_encode_tag(ASN_BIT_STR),opBITSTR],OCTET_STRING=>[asn_encode_tag(ASN_OCTET_STR),opSTRING],STRING=>[asn_encode_tag(ASN_OCTET_STR),opSTRING],NULL=>[asn_encode_tag(ASN_NULL),opNULL],OBJECT_IDENTIFIER=>[asn_encode_tag(ASN_OBJECT_ID),opOBJID],REAL=>[asn_encode_tag(ASN_REAL),opREAL],ENUMERATED=>[asn_encode_tag(ASN_ENUMERATED),opINTEGER],ENUM=>[asn_encode_tag(ASN_ENUMERATED),opINTEGER],'RELATIVE-OID'=>[asn_encode_tag(ASN_RELATIVE_OID),opROID],SEQUENCE=>[asn_encode_tag(ASN_SEQUENCE|ASN_CONSTRUCTOR),opSEQUENCE],EXPLICIT=>[asn_encode_tag(ASN_SEQUENCE|ASN_CONSTRUCTOR),opEXPLICIT],SET=>[asn_encode_tag(ASN_SET|ASN_CONSTRUCTOR),opSET],ObjectDescriptor=>[asn_encode_tag(ASN_UNIVERSAL|7),opSTRING],UTF8String=>[asn_encode_tag(ASN_UNIVERSAL|12),opUTF8],NumericString=>[asn_encode_tag(ASN_UNIVERSAL|18),opSTRING],PrintableString=>[asn_encode_tag(ASN_UNIVERSAL|19),opSTRING],TeletexString=>[asn_encode_tag(ASN_UNIVERSAL|20),opSTRING],T61String=>[asn_encode_tag(ASN_UNIVERSAL|20),opSTRING],VideotexString=>[asn_encode_tag(ASN_UNIVERSAL|21),opSTRING],IA5String=>[asn_encode_tag(ASN_UNIVERSAL|22),opSTRING],UTCTime=>[asn_encode_tag(ASN_UNIVERSAL|23),opUTIME],GeneralizedTime=>[asn_encode_tag(ASN_UNIVERSAL|24),opGTIME],GraphicString=>[asn_encode_tag(ASN_UNIVERSAL|25),opSTRING],VisibleString=>[asn_encode_tag(ASN_UNIVERSAL|26),opSTRING],ISO646String=>[asn_encode_tag(ASN_UNIVERSAL|26),opSTRING],GeneralString=>[asn_encode_tag(ASN_UNIVERSAL|27),opSTRING],CharacterString=>[asn_encode_tag(ASN_UNIVERSAL|28),opSTRING],UniversalString=>[asn_encode_tag(ASN_UNIVERSAL|28),opSTRING],BMPString=>[asn_encode_tag(ASN_UNIVERSAL|30),opSTRING],BCDString=>[asn_encode_tag(ASN_OCTET_STR),opBCD],CHOICE=>['',opCHOICE],ANY=>['',opANY],EXTENSION_MARKER=>['',opEXTENSIONS],);
my$tagdefault=1;
sub need_explicit{(defined($_[0])&&(defined($_[1])?$_[1]:$tagdefault));}sub explicit{my$op=shift;
my@seq=@$op;
@seq[cTYPE,cCHILD,cVAR,cLOOP]=('EXPLICIT',[$op],undef,undef);
@{$op}[cTAG,cOPT]=();
\@seq;}sub constWORD (){1}sub constCLASS (){2}sub constSEQUENCE (){3}sub constSET (){4}sub constCHOICE (){5}sub constOF (){6}sub constIMPLICIT (){7}sub constEXPLICIT (){8}sub constOPTIONAL (){9}sub constLBRACE (){10}sub constRBRACE (){11}sub constCOMMA (){12}sub constANY (){13}sub constASSIGN (){14}sub constNUMBER (){15}sub constENUM (){16}sub constCOMPONENTS (){17}sub constPOSTRBRACE (){18}sub constDEFINED (){19}sub constBY (){20}sub constEXTENSION_MARKER (){21}sub constYYERRCODE (){256}my@yylhs=(-1,0,0,2,2,3,3,6,6,6,6,8,13,13,12,14,14,14,9,9,9,10,18,18,18,18,18,19,19,11,16,16,20,20,20,21,21,1,1,1,22,22,22,24,24,24,24,23,23,23,23,15,15,4,4,5,5,5,17,17,25,7,7,);
my@yylen=(2,1,1,3,4,4,1,1,1,1,1,3,1,1,6,1,1,1,4,4,4,4,1,1,1,2,1,0,3,1,1,2,1,3,3,4,1,0,1,2,1,3,3,2,1,1,1,4,1,3,1,0,1,0,1,0,1,1,1,3,2,0,1,);
my@yydefred=(0,0,54,0,50,0,1,0,0,48,0,40,0,0,0,0,57,56,0,0,0,3,0,6,0,11,0,0,0,0,49,0,41,42,0,22,0,0,0,0,46,44,0,45,0,29,47,4,0,0,0,0,7,8,9,10,0,25,0,52,43,0,0,0,0,36,0,0,32,62,5,0,0,0,58,0,18,19,0,20,0,0,28,60,21,0,0,0,34,33,59,0,0,17,15,16,0,35,14,);
my@yydgoto=(5,6,7,21,8,18,51,70,9,52,53,54,55,44,96,60,66,73,45,57,67,68,10,11,46,74,);
my@yysindex=(2,58,0,8,0,0,0,11,123,0,3,0,59,123,19,73,0,0,92,7,7,0,123,0,119,0,59,107,109,116,0,82,0,0,119,0,107,109,84,126,0,0,90,0,132,0,0,0,7,7,10,139,0,0,0,0,141,0,143,0,0,82,156,159,82,0,160,4,0,0,0,171,158,6,0,123,0,0,123,0,10,10,0,0,0,143,124,119,0,0,0,107,109,0,0,0,90,0,0,);
my@yyrindex=(155,105,0,0,0,0,0,174,111,0,80,0,105,138,0,0,0,0,0,161,145,0,138,0,0,0,105,0,0,0,0,105,0,0,0,0,29,33,70,74,0,0,46,0,0,0,0,0,45,45,0,54,0,0,0,0,0,0,0,0,0,105,0,0,105,0,0,164,0,0,0,0,0,0,0,138,0,0,138,0,0,165,0,0,0,0,0,0,0,0,0,89,93,0,0,0,25,0,0,);
my@yygindex=(0,85,0,151,1,-12,91,0,47,-18,-19,-17,157,0,0,83,0,0,0,0,0,-3,0,127,0,95,);
sub constYYTABLESIZE (){181}my@yytable=(30,24,13,1,2,41,40,42,31,2,34,64,15,22,14,19,80,84,85,3,25,20,81,4,3,51,51,22,4,23,23,65,13,24,24,12,51,51,23,13,23,23,24,51,24,24,51,23,53,53,53,24,53,53,61,61,37,51,51,23,2,2,75,86,51,78,87,94,93,95,27,27,12,23,26,26,3,88,89,27,38,27,27,26,2,26,26,26,27,23,23,38,26,24,24,27,28,29,23,59,23,23,24,56,24,24,53,23,53,53,53,24,53,53,55,55,55,48,53,49,35,53,36,37,29,35,50,91,92,29,16,17,38,62,63,39,58,38,61,55,39,55,55,55,72,39,32,33,53,53,53,55,53,53,55,37,39,69,53,53,53,71,53,53,53,53,53,76,53,53,77,79,82,83,2,30,31,47,97,98,90,43,);
my@yycheck=(18,13,1,1,2,24,24,24,1,2,22,1,1,12,6,12,12,11,12,17,1,18,18,21,17,0,1,26,21,0,1,21,31,0,1,6,11,12,9,6,11,12,9,18,11,12,0,18,3,4,5,18,7,8,0,1,11,11,12,12,2,2,61,75,18,64,78,86,86,86,0,1,14,26,0,1,17,80,81,9,0,11,12,9,2,11,12,14,18,0,1,11,18,0,1,3,4,5,9,9,11,12,9,19,11,12,1,18,3,4,5,18,7,8,3,4,5,10,13,10,1,16,3,4,5,1,10,3,4,5,7,8,13,48,49,16,10,13,6,1,16,3,4,5,1,0,19,20,3,4,5,13,7,8,16,0,11,18,3,4,5,20,7,8,3,4,5,11,7,8,11,11,1,15,0,11,11,26,87,96,85,24,);
sub constYYFINAL (){5}sub constYYMAXTOKEN (){21}sub yyclearin{$yychar=-1;}sub yyerrok{$yyerrflag=0;}sub YYERROR{++$yynerrs;
&yy_err_recover;}sub yy_err_recover{if($yyerrflag<3){$yyerrflag=3;
while(1){if(($yyn=$yysindex[$yyss[$yyssp]])&&($yyn+=constYYERRCODE())>=0&&$yyn<=$#yycheck&&$yycheck[$yyn]==constYYERRCODE()){$yyss[++$yyssp]=$yystate=$yytable[$yyn];
$yyvs[++$yyvsp]=$yylval;
next yyloop;}else{return(1)if$yyssp<=0;
--$yyssp;
--$yyvsp;}}}else{return(1)if$yychar==0;
$yychar=-1;
next yyloop;}0;}sub yyparse{if($yys=$ENV{'YYDEBUG'}){$yydebug=int($1)if$yys=~/^(\d)/;}$yynerrs=0;
$yyerrflag=0;
$yychar=(-1);
$yyssp=0;
$yyvsp=0;
$yyss[$yyssp]=$yystate=0;
yyloop:
while(1){yyreduce:{last yyreduce if($yyn=$yydefred[$yystate]);
if($yychar<0){if(($yychar=&yylex)<0){$yychar=0;}}if(($yyn=$yysindex[$yystate])&&($yyn+=$yychar)>=0&&$yyn<=$#yycheck&&$yycheck[$yyn]==$yychar){$yyss[++$yyssp]=$yystate=$yytable[$yyn];
$yyvs[++$yyvsp]=$yylval;
$yychar=(-1);
--$yyerrflag if$yyerrflag>0;
next yyloop;}if(($yyn=$yyrindex[$yystate])&&($yyn+=$yychar)>=0&&$yyn<=$#yycheck&&$yycheck[$yyn]==$yychar){$yyn=$yytable[$yyn];
last yyreduce;}if(!$yyerrflag){&yyerror('syntax error');
++$yynerrs;}return undef if&yy_err_recover;}$yym=$yylen[$yyn];
$yyval=$yyvs[$yyvsp+1-$yym];
switch:
{my$label="State$yyn";
goto$label if exists$yystate{$label};
last switch;
State1:{{$yyval={''=>$yyvs[$yyvsp-0]};
last switch;}}State3:{{$yyval={$yyvs[$yyvsp-2],[$yyvs[$yyvsp-0]]};
last switch;}}State4:{{$yyval=$yyvs[$yyvsp-3];
$yyval->{$yyvs[$yyvsp-2]}=[$yyvs[$yyvsp-0]];
last switch;}}State5:{{$yyvs[$yyvsp-1]->[cTAG]=$yyvs[$yyvsp-3];
$yyval=need_explicit($yyvs[$yyvsp-3],$yyvs[$yyvsp-2])?explicit($yyvs[$yyvsp-1]):$yyvs[$yyvsp-1];
last switch;}}State11:{{@{$yyval=[]}[cTYPE,cCHILD]=('COMPONENTS',$yyvs[$yyvsp-0]);
last switch;}}State14:{{$yyvs[$yyvsp-1]->[cTAG]=$yyvs[$yyvsp-3];
@{$yyval=[]}[cTYPE,cCHILD,cLOOP,cOPT]=($yyvs[$yyvsp-5],[$yyvs[$yyvsp-1]],1,$yyvs[$yyvsp-0]);
$yyval=explicit($yyval)if need_explicit($yyvs[$yyvsp-3],$yyvs[$yyvsp-2]);
last switch;}}State18:{{@{$yyval=[]}[cTYPE,cCHILD]=('SEQUENCE',$yyvs[$yyvsp-1]);
last switch;}}State19:{{@{$yyval=[]}[cTYPE,cCHILD]=('SET',$yyvs[$yyvsp-1]);
last switch;}}State20:{{@{$yyval=[]}[cTYPE,cCHILD]=('CHOICE',$yyvs[$yyvsp-1]);
last switch;}}State21:{{@{$yyval=[]}[cTYPE]=('ENUM');
last switch;}}State22:{{@{$yyval=[]}[cTYPE]=$yyvs[$yyvsp-0];
last switch;}}State23:{{@{$yyval=[]}[cTYPE]=$yyvs[$yyvsp-0];
last switch;}}State24:{{@{$yyval=[]}[cTYPE]=$yyvs[$yyvsp-0];
last switch;}}State25:{{@{$yyval=[]}[cTYPE,cCHILD,cDEFINE]=('ANY',undef,$yyvs[$yyvsp-0]);
last switch;}}State26:{{@{$yyval=[]}[cTYPE]=$yyvs[$yyvsp-0];
last switch;}}State27:{{$yyval=undef;
last switch;}}State28:{{$yyval=$yyvs[$yyvsp-0];
last switch;}}State30:{{$yyval=$yyvs[$yyvsp-0];
last switch;}}State31:{{$yyval=$yyvs[$yyvsp-1];
last switch;}}State32:{{$yyval=[$yyvs[$yyvsp-0]];
last switch;}}State33:{{push@{$yyval=$yyvs[$yyvsp-2]},$yyvs[$yyvsp-0];
last switch;}}State34:{{push@{$yyval=$yyvs[$yyvsp-2]},$yyvs[$yyvsp-0];
last switch;}}State35:{{@{$yyval=$yyvs[$yyvsp-0]}[cVAR,cTAG]=($yyvs[$yyvsp-3],$yyvs[$yyvsp-2]);
$yyval=explicit($yyval)if need_explicit($yyvs[$yyvsp-2],$yyvs[$yyvsp-1]);
last switch;}}State36:{{@{$yyval=[]}[cTYPE]='EXTENSION_MARKER';
last switch;}}State37:{{$yyval=[];
last switch;}}State38:{{my$extension=0;
$yyval=[];
for my $i(@{$yyvs[$yyvsp-0]}){$extension=1 if$i->[cTYPE]eq 'EXTENSION_MARKER';
$i->[cEXT]=$i->[cOPT];
$i->[cEXT]=1 if$extension;
push@{$yyval},$i unless$i->[cTYPE]eq 'EXTENSION_MARKER';}my$e=[];
$e->[cTYPE]='EXTENSION_MARKER';
push@{$yyval},$e if$extension;
last switch;}}State39:{{my$extension=0;
$yyval=[];
for my $i(@{$yyvs[$yyvsp-1]}){$extension=1 if$i->[cTYPE]eq 'EXTENSION_MARKER';
$i->[cEXT]=$i->[cOPT];
$i->[cEXT]=1 if$extension;
push@{$yyval},$i unless$i->[cTYPE]eq 'EXTENSION_MARKER';}my$e=[];
$e->[cTYPE]='EXTENSION_MARKER';
push@{$yyval},$e if$extension;
last switch;}}State40:{{$yyval=[$yyvs[$yyvsp-0]];
last switch;}}State41:{{push@{$yyval=$yyvs[$yyvsp-2]},$yyvs[$yyvsp-0];
last switch;}}State42:{{push@{$yyval=$yyvs[$yyvsp-2]},$yyvs[$yyvsp-0];
last switch;}}State43:{{@{$yyval=$yyvs[$yyvsp-1]}[cOPT]=($yyvs[$yyvsp-0]);
last switch;}}State47:{{@{$yyval=$yyvs[$yyvsp-0]}[cVAR,cTAG]=($yyvs[$yyvsp-3],$yyvs[$yyvsp-2]);
$yyval->[cOPT]=$yyvs[$yyvsp-3]if$yyval->[cOPT];
$yyval=explicit($yyval)if need_explicit($yyvs[$yyvsp-2],$yyvs[$yyvsp-1]);
last switch;}}State49:{{@{$yyval=$yyvs[$yyvsp-0]}[cTAG]=($yyvs[$yyvsp-2]);
$yyval=explicit($yyval)if need_explicit($yyvs[$yyvsp-2],$yyvs[$yyvsp-1]);
last switch;}}State50:{{@{$yyval=[]}[cTYPE]='EXTENSION_MARKER';
last switch;}}State51:{{$yyval=undef;
last switch;}}State52:{{$yyval=1;
last switch;}}State53:{{$yyval=undef;
last switch;}}State55:{{$yyval=undef;
last switch;}}State56:{{$yyval=1;
last switch;}}State57:{{$yyval=0;
last switch;}}State58:{{last switch;}}State59:{{last switch;}}State60:{{last switch;}}State61:{{last switch;}}State62:{{last switch;}}}$yyssp-=$yym;
$yystate=$yyss[$yyssp];
$yyvsp-=$yym;
$yym=$yylhs[$yyn];
if($yystate==0&&$yym==0){$yystate=constYYFINAL();
$yyss[++$yyssp]=constYYFINAL();
$yyvs[++$yyvsp]=$yyval;
if($yychar<0){if(($yychar=&yylex)<0){$yychar=0;}}return$yyvs[$yyvsp]if$yychar==0;
next yyloop;}if(($yyn=$yygindex[$yym])&&($yyn+=$yystate)>=0&&$yyn<=$#yycheck&&$yycheck[$yyn]==$yystate){$yystate=$yytable[$yyn];}else{$yystate=$yydgoto[$yym];}$yyss[++$yyssp]=$yystate;
$yyvs[++$yyvsp]=$yyval;}}my%reserved=('OPTIONAL'=>constOPTIONAL(),'CHOICE'=>constCHOICE(),'OF'=>constOF(),'IMPLICIT'=>constIMPLICIT(),'EXPLICIT'=>constEXPLICIT(),'SEQUENCE'=>constSEQUENCE(),'SET'=>constSET(),'ANY'=>constANY(),'ENUM'=>constENUM(),'ENUMERATED'=>constENUM(),'COMPONENTS'=>constCOMPONENTS(),'{'=>constLBRACE(),'}'=>constRBRACE(),','=>constCOMMA(),'::='=>constASSIGN(),'DEFINED'=>constDEFINED(),'BY'=>constBY());
my$reserved=join("|",reverse sort grep{/\w/}keys%reserved);
my%tag_class=(APPLICATION=>ASN_APPLICATION,UNIVERSAL=>ASN_UNIVERSAL,PRIVATE=>ASN_PRIVATE,CONTEXT=>ASN_CONTEXT,''=>ASN_CONTEXT);
my$pos;
my$last_pos;
my@stacked;
sub parse{local(*asn)=\($_[0]);
$tagdefault=$_[1]eq 'EXPLICIT'?1:0;
($pos,$last_pos,@stacked)=();
eval{local$SIG{__DIE__};
compile(verify(yyparse()));}}sub compile_one{my$tree=shift;
my$ops=shift;
my$name=shift;
foreach my $op(@$ops){next unless ref($op)eq 'ARRAY';
bless$op;
my$type=$op->[cTYPE];
if(exists$base_type{$type}){$op->[cTYPE]=$base_type{$type}->[1];
$op->[cTAG]=defined($op->[cTAG])?asn_encode_tag($op->[cTAG]):$base_type{$type}->[0];}else{die"Unknown type '$type'\n" unless exists$tree->{$type};
my$ref=compile_one($tree,$tree->{$type},defined($op->[cVAR])?$name.".".$op->[cVAR]:$name);
if(defined($op->[cTAG])&&$ref->[0]->[cTYPE]==opCHOICE){@{$op}[cTYPE,cCHILD]=(opSEQUENCE,$ref);}else{@{$op}[cTYPE,cCHILD,cLOOP]=@{$ref->[0]}[cTYPE,cCHILD,cLOOP];}$op->[cTAG]=defined($op->[cTAG])?asn_encode_tag($op->[cTAG]):$ref->[0]->[cTAG];}$op->[cTAG]|=pack("C",ASN_CONSTRUCTOR)if length$op->[cTAG]&&($op->[cTYPE]==opSET||$op->[cTYPE]==opEXPLICIT||$op->[cTYPE]==opSEQUENCE);
if($op->[cCHILD]){;
compile_one($tree,$op->[cCHILD],defined($op->[cVAR])?$name.".".$op->[cVAR]:$name);
if($op->[cTYPE]==opCHOICE&&defined($op->[cTAG])&&length($op->[cTAG])){$op=bless explicit($op);
$op->[cTYPE]=opSEQUENCE;}if(@{$op->[cCHILD]}>1){;
if($op->[cTYPE]==opSET){;
my@tags=map{length($_->[cTAG])?$_->[cTAG]:$_->[cTYPE]==opCHOICE?(sort map{$_->[cTAG]}$_->[cCHILD])[0]:''}@{$op->[cCHILD]};
@{$op->[cCHILD]}=@{$op->[cCHILD]}[sort{$tags[$a]cmp$tags[$b]}0..$#tags];}}else{;
$op->[cTYPE]=opSEQUENCE if$op->[cTYPE]==opSET;}}}$ops;}sub compile{my$tree=shift;
while(my($k,$v)=each%$tree){compile_one($tree,$v,$k);}$tree;}sub verify{my$tree=shift or return;
my$err="";
while(my($name,$ops)=each%$tree){my$stash={};
my@scope=();
my$path="";
my$idx=0;
while($ops){if($idx<@$ops){my$op=$ops->[$idx++];
my$var;
if(defined($var=$op->[cVAR])){$err.="$name: $path.$var used multiple times\n" if$stash->{$var}++;}if(defined$op->[cCHILD]){if(ref$op->[cCHILD]){push@scope,[$stash,$path,$ops,$idx];
if(defined$var){$stash={};
$path.=".".$var;}$idx=0;
$ops=$op->[cCHILD];}elsif($op->[cTYPE]eq 'COMPONENTS'){splice(@$ops, --$idx,1,expand_ops($tree,$op->[cCHILD]));}else{die"Internal error\n";}}}else{my$s=pop@scope or last;
($stash,$path,$ops,$idx)=@$s;}}}die$err if length$err;
$tree;}sub expand_ops{my$tree=shift;
my$want=shift;
my$seen=shift||{};
die"COMPONENTS OF loop $want\n" if$seen->{$want}++;
die"Undefined macro $want\n" unless exists$tree->{$want};
my$ops=$tree->{$want};
die"Bad macro for COMPUNENTS OF '$want'\n" unless@$ops==1&&($ops->[0]->[cTYPE]eq 'SEQUENCE'||$ops->[0]->[cTYPE]eq 'SET')&&ref$ops->[0]->[cCHILD];
$ops=$ops->[0]->[cCHILD];
for(my$idx=0;$idx<@$ops;){my$op=$ops->[$idx++];
if($op->[cTYPE]eq 'COMPONENTS'){splice(@$ops, --$idx,1,expand_ops($tree,$op->[cCHILD],$seen));}}@$ops;}sub _yylex{my$ret=&_yylex;
warn$ret;
$ret;}sub yylex{return shift@stacked if@stacked;
while($asn=~/\G(?:
        (\s+|--[^\n]*)
        |
        ([,{}]|::=)
        |
        ($reserved)\b
        |
        (
        (?:OCTET|BIT)\s+STRING
        |
        OBJECT\s+IDENTIFIER
        |
        RELATIVE-OID
        )\b
        |
        (\w+(?:-\w+)*)
        |
        \[\s*
        (
        (?:(?:APPLICATION|PRIVATE|UNIVERSAL|CONTEXT)\s+)?
        \d+
        )
        \s*\]
        |
        \((\d+)\)
        |
        (\.\.\.)
        )/sxgo
  ){($last_pos,$pos)=($pos,pos($asn));
next if defined$1;
if(defined$2 or defined$3){my$ret=$+;
if($ret eq '}'){my$p=pos($asn);
my@tmp=@stacked;
@stacked=();
pos($asn)=$p if yylex()!=constCOMMA();
@stacked=(@tmp,constPOSTRBRACE());}return$reserved{$yylval=$ret};}if(defined$4){($yylval=$+)=~s/\s+/_/g;
return constWORD();}if(defined$5){$yylval=$+;
return constWORD();}if(defined$6){my($class,$num)=($+=~/^([A-Z]*)\s*(\d+)$/);
$yylval=asn_tag($tag_class{$class},$num);
return constCLASS();}if(defined$7){$yylval=$+;
return constNUMBER();}if(defined$8){return constEXTENSION_MARKER();}die"Internal error\n";}die"Parse error before ",substr($asn,$pos,40),"\n" unless$pos==length($asn);
0;}sub yyerror{die@_," ",substr($asn,$last_pos,40),"\n";}1;
%yystate=('State51','','State34','','State11','','State33','','State24','','State47','','State40','','State31','','State37','','State23','','State22','','State21','','State57','','State39','','State56','','State20','','State25','','State38','','State62','','State14','','State19','','State5','','State53','','State26','','State27','','State50','','State36','','State4','','State3','','State32','','State49','','State43','','State30','','State35','','State52','','State55','','State42','','State28','','State58','','State61','','State41','','State18','','State59','','State1','','State60','');
package Math::BigInt;
use 5.006001;
use strict;
use warnings;
use Carp ();
our$VERSION='1.999811';
our@ISA=qw(Exporter);
our@EXPORT_OK=qw(objectify bgcd blcm);
my$class="Math::BigInt";
use overload '+'=>sub{$_[0]->copy()->badd($_[1]);},'-'=>sub{my$c=$_[0]->copy;
$_[2]?$c->bneg()->badd($_[1]):$c->bsub($_[1]);},'*'=>sub{$_[0]->copy()->bmul($_[1]);},'/'=>sub{$_[2]?ref($_[0])->new($_[1])->bdiv($_[0]):$_[0]->copy->bdiv($_[1]);},'%'=>sub{$_[2]?ref($_[0])->new($_[1])->bmod($_[0]):$_[0]->copy->bmod($_[1]);},'**'=>sub{$_[2]?ref($_[0])->new($_[1])->bpow($_[0]):$_[0]->copy->bpow($_[1]);},'<<'=>sub{$_[2]?ref($_[0])->new($_[1])->blsft($_[0]):$_[0]->copy->blsft($_[1]);},'>>'=>sub{$_[2]?ref($_[0])->new($_[1])->brsft($_[0]):$_[0]->copy->brsft($_[1]);},'+='=>sub{$_[0]->badd($_[1]);},'-='=>sub{$_[0]->bsub($_[1]);},'*='=>sub{$_[0]->bmul($_[1]);},'/='=>sub{scalar$_[0]->bdiv($_[1]);},'%='=>sub{$_[0]->bmod($_[1]);},'**='=>sub{$_[0]->bpow($_[1]);},'<<='=>sub{$_[0]->blsft($_[1]);},'>>='=>sub{$_[0]->brsft($_[1]);},'<'=>sub{$_[2]?ref($_[0])->new($_[1])->blt($_[0]):$_[0]->blt($_[1]);},'<='=>sub{$_[2]?ref($_[0])->new($_[1])->ble($_[0]):$_[0]->ble($_[1]);},'>'=>sub{$_[2]?ref($_[0])->new($_[1])->bgt($_[0]):$_[0]->bgt($_[1]);},'>='=>sub{$_[2]?ref($_[0])->new($_[1])->bge($_[0]):$_[0]->bge($_[1]);},'=='=>sub{$_[0]->beq($_[1]);},'!='=>sub{$_[0]->bne($_[1]);},'<=>'=>sub{my$cmp=$_[0]->bcmp($_[1]);
defined($cmp)&&$_[2]?-$cmp:$cmp;},'cmp'=>sub{$_[2]?"$_[1]" cmp$_[0]->bstr():$_[0]->bstr()cmp"$_[1]";},'&'=>sub{$_[2]?ref($_[0])->new($_[1])->band($_[0]):$_[0]->copy->band($_[1]);},'&='=>sub{$_[0]->band($_[1]);},'|'=>sub{$_[2]?ref($_[0])->new($_[1])->bior($_[0]):$_[0]->copy->bior($_[1]);},'|='=>sub{$_[0]->bior($_[1]);},'^'=>sub{$_[2]?ref($_[0])->new($_[1])->bxor($_[0]):$_[0]->copy->bxor($_[1]);},'^='=>sub{$_[0]->bxor($_[1]);},'neg'=>sub{$_[0]->copy()->bneg();},'~'=>sub{$_[0]->copy()->bnot();},'++'=>sub{$_[0]->binc()},'--'=>sub{$_[0]->bdec()},'atan2'=>sub{$_[2]?ref($_[0])->new($_[1])->batan2($_[0]):$_[0]->copy()->batan2($_[1]);},'cos'=>sub{$_[0]->copy->bcos();},'sin'=>sub{$_[0]->copy->bsin();},'exp'=>sub{$_[0]->copy()->bexp($_[1]);},'abs'=>sub{$_[0]->copy()->babs();},'log'=>sub{$_[0]->copy()->blog();},'sqrt'=>sub{$_[0]->copy()->bsqrt();},'int'=>sub{$_[0]->copy()->bint();},'bool'=>sub{$_[0]->is_zero()?'':1;},'""'=>sub{$_[0]->bstr();},'0+'=>sub{$_[0]->numify();},'='=>sub{$_[0]->copy();},;
our$round_mode='even';
our$accuracy=undef;
our$precision=undef;
our$div_scale=40;
our$upgrade=undef;
our$downgrade=undef;
our$_trap_nan=0;
our$_trap_inf=0;
my$nan='NaN';
my$CALC='Math::BigInt::Calc';
my$IMPORT=0;
my%WARN;
my%CAN;
my%CALLBACKS;
my$EMU_LIB='Math/BigInt/CalcEmu.pm';
our$rnd_mode='even';
sub TIESCALAR{my($class)=@_;
bless\$round_mode,$class;}sub FETCH{return$round_mode;}sub STORE{$rnd_mode=$_[0]->round_mode($_[1]);}BEGIN{tie$rnd_mode,'Math::BigInt';
*as_int=\&as_number;
*is_pos=\&is_positive;
*is_neg=\&is_negative;}sub round_mode{no strict 'refs';
my$self=shift;
my$class=ref($self)||$self||__PACKAGE__;
if(defined$_[0]){my$m=shift;
if($m!~/^(even|odd|\+inf|\-inf|zero|trunc|common)$/){Carp::croak("Unknown round mode '$m'");}return${"${class}::round_mode"}=$m;}${"${class}::round_mode"};}sub upgrade{no strict 'refs';
my$self=shift;
my$class=ref($self)||$self||__PACKAGE__;
if(@_>0){return${"${class}::upgrade"}=$_[0];}${"${class}::upgrade"};}sub downgrade{no strict 'refs';
my$self=shift;
my$class=ref($self)||$self||__PACKAGE__;
if(@_>0){return${"${class}::downgrade"}=$_[0];}${"${class}::downgrade"};}sub div_scale{no strict 'refs';
my$self=shift;
my$class=ref($self)||$self||__PACKAGE__;
if(defined$_[0]){if($_[0]<0){Carp::croak('div_scale must be greater than zero');}${"${class}::div_scale"}=$_[0];}${"${class}::div_scale"};}sub accuracy{my$x=shift;
my$class=ref($x)||$x||__PACKAGE__;
no strict 'refs';
if(@_>0){my$a=shift;
$a=$a->numify()if ref($a)&&$a->can('numify');
if(defined$a){if(!$a||$a<=0){Carp::croak('Argument to accuracy must be greater than zero');}if(int($a)!=$a){Carp::croak('Argument to accuracy must be an integer');}}if(ref($x)){$x->bround($a)if$a;
$x->{_a}=$a;
delete$x->{_p};
$a=${"${class}::accuracy"}unless defined$a;}else{${"${class}::accuracy"}=$a;
${"${class}::precision"}=undef;}return$a;}my$a;
$a=$x->{_a}if ref($x);
$a=${"${class}::accuracy"}if!defined$a;
$a;}sub precision{my$x=shift;
my$class=ref($x)||$x||__PACKAGE__;
no strict 'refs';
if(@_>0){my$p=shift;
$p=$p->numify()if ref($p)&&$p->can('numify');
if((defined$p)&&(int($p)!=$p)){Carp::croak('Argument to precision must be an integer');}if(ref($x)){$x->bfround($p)if$p;
$x->{_p}=$p;
delete$x->{_a};
$p=${"${class}::precision"}unless defined$p;}else{${"${class}::precision"}=$p;
${"${class}::accuracy"}=undef;}return$p;}my$p;
$p=$x->{_p}if ref($x);
$p=${"${class}::precision"}if!defined$p;
$p;}sub config{my$class=shift||__PACKAGE__;
no strict 'refs';
if(@_>1||(@_==1&&(ref($_[0])eq 'HASH'))){my$args=$_[0];
if(ref($args)ne 'HASH'){$args={@_};}my$set_args={};
foreach my $key(qw/
accuracy precision
round_mode div_scale
upgrade downgrade
trap_inf trap_nan
/){$set_args->{$key}=$args->{$key}if exists$args->{$key};
delete$args->{$key};}if(keys%$args>0){Carp::croak("Illegal key(s) '",join("', '",keys%$args),"' passed to $class\->config()");}foreach my $key(keys%$set_args){if($key=~/^trap_(inf|nan)\z/){${"${class}::_trap_$1"}=($set_args->{"trap_$1"}?1:0);
next;}$class->$key($set_args->{$key});}}my$cfg={lib=>$CALC,lib_version=>${"${CALC}::VERSION"},class=>$class,trap_nan=>${"${class}::_trap_nan"},trap_inf=>${"${class}::_trap_inf"},version=>${"${class}::VERSION"},};
foreach my $key(qw/
accuracy precision
round_mode div_scale
upgrade downgrade
/){$cfg->{$key}=${"${class}::$key"};}if(@_==1&&(ref($_[0])ne 'HASH')){return$cfg->{$_[0]};}$cfg;}sub _scale_a{my($x,$scale,$mode)=@_;
$scale=$x->{_a}unless defined$scale;
no strict 'refs';
my$class=ref($x);
$scale=${$class.'::accuracy'}unless defined$scale;
$mode=${$class.'::round_mode'}unless defined$mode;
if(defined$scale){$scale=$scale->can('numify')?$scale->numify():"$scale" if ref($scale);
$scale=int($scale);}($scale,$mode);}sub _scale_p{my($x,$scale,$mode)=@_;
$scale=$x->{_p}unless defined$scale;
no strict 'refs';
my$class=ref($x);
$scale=${$class.'::precision'}unless defined$scale;
$mode=${$class.'::round_mode'}unless defined$mode;
if(defined$scale){$scale=$scale->can('numify')?$scale->numify():"$scale" if ref($scale);
$scale=int($scale);}($scale,$mode);}sub new{my$self=shift;
my$selfref=ref$self;
my$class=$selfref||$self;
return$self->bzero()unless@_;
my($wanted,$a,$p,$r)=@_;
$self=$selfref?$self->copy():bless{},$class;
unless(defined$wanted){return$self->bzero($a,$p,$r);}if(ref($wanted)&&$wanted->isa($class)){my$copy=$class->copy($wanted);
if($selfref){%$self=%$copy;}else{$self=$copy;}return$self;}$class->import()if$IMPORT==0;
if(!ref($wanted)&&$wanted=~/ ^
        ([+-]?)            # optional sign
        ([1-9][0-9]*)      # non-zero significand
        (\.0*)?            # ... with optional zero fraction
        ([Ee][+-]?0+)?     # optional zero exponent
        \z
        /x
  ){my$sgn=$1;
my$abs=$2;
$self->{sign}=$sgn||'+';
$self->{value}=$CALC->_new($abs);
no strict 'refs';
if(defined($a)||defined($p)||defined(${"${class}::precision"})||defined(${"${class}::accuracy"})){$self->round($a,$p,$r)unless@_>=3&&!defined$a&&!defined$p;}return$self;}if($wanted=~/^\s*([+-]?)inf(inity)?\s*\z/i){my$sgn=$1||'+';
$self->{sign}=$sgn.'inf';
return$class->binf($sgn);}if($wanted=~/^\s*([+-]?)nan\s*\z/i){$self=$class->bnan();
$self->round($a,$p,$r)unless@_>=3&&!defined$a&&!defined$p;
return$self;}if($wanted=~/^\s*[+-]?0[Xx]/){$self=$class->from_hex($wanted);
$self->round($a,$p,$r)unless@_>=3&&!defined$a&&!defined$p;
return$self;}if($wanted=~/^\s*[+-]?0[Bb]/){$self=$class->from_bin($wanted);
$self->round($a,$p,$r)unless@_>=3&&!defined$a&&!defined$p;
return$self;}my($mis,$miv,$mfv,$es,$ev)=_split($wanted);
if(!ref$mis){if($_trap_nan){Carp::croak("$wanted is not a number in $class");}$self->{value}=$CALC->_zero();
$self->{sign}=$nan;
return$self;}if(!ref$miv){$self->{value}=$mis->{value};
$self->{sign}=$mis->{sign};
return$self;}$self->{sign}=$$mis;
$self->{value}=$CALC->_zero();
my$e=int("$$es$$ev");
if($e>0){my$diff=$e-CORE::length($$mfv);
if($diff<0){if($_trap_nan){Carp::croak("$wanted not an integer in $class");}return$upgrade->new($wanted,$a,$p,$r)if defined$upgrade;
$self->{sign}=$nan;}else{$$miv=$$miv.($$mfv.'0' x$diff);}}else{if($$mfv ne ''){if($_trap_nan){Carp::croak("$wanted not an integer in $class");}return$upgrade->new($wanted,$a,$p,$r)if defined$upgrade;
$self->{sign}=$nan;}elsif($e<0){my$frac=substr($$miv,$e);
substr($$miv,$e)="";
if($frac=~/[^0]/){if($_trap_nan){Carp::croak("$wanted not an integer in $class");}return$upgrade->new($wanted,$a,$p,$r)if defined$upgrade;
$self->{sign}=$nan;}}}unless($self->{sign}eq$nan){$self->{sign}='+' if$$miv eq '0';
$self->{value}=$CALC->_new($$miv)if$self->{sign}=~/^[+-]$/;}$self->round($a,$p,$r)unless@_>=3&&!defined$a&&!defined$p;
$self;}sub from_hex{my$self=shift;
my$selfref=ref$self;
my$class=$selfref||$self;
return if$selfref&&$self->modify('from_hex');
my$str=shift;
$self=$class->bzero()unless$selfref;
if($str=~s/
        ^
            \s*
            ( [+-]? )
            (0?x)?
            (
            [0-9a-fA-F]*
            ( _ [0-9a-fA-F]+ )*
            )
            \s*
            $
        //x
  ){my$sign=$1;
my$chrs=$3;
$chrs=~tr/_//d;
$chrs='0' unless CORE::length$chrs;
$self->{value}=$CALC->_from_hex('0x'.$chrs);
$self->{sign}=$sign eq '-'&&!$CALC->_is_zero($self->{value})?'-':'+';
return$self;}return$self->bnan();}sub from_oct{my$self=shift;
my$selfref=ref$self;
my$class=$selfref||$self;
return if$selfref&&$self->modify('from_oct');
my$str=shift;
$self=$class->bzero()unless$selfref;
if($str=~s/
        ^
            \s*
            ( [+-]? )
            (
            [0-7]*
            ( _ [0-7]+ )*
            )
            \s*
            $
        //x
  ){my$sign=$1;
my$chrs=$2;
$chrs=~tr/_//d;
$chrs='0' unless CORE::length$chrs;
$self->{value}=$CALC->_from_oct('0'.$chrs);
$self->{sign}=$sign eq '-'&&!$CALC->_is_zero($self->{value})?'-':'+';
return$self;}return$self->bnan();}sub from_bin{my$self=shift;
my$selfref=ref$self;
my$class=$selfref||$self;
return if$selfref&&$self->modify('from_bin');
my$str=shift;
$self=$class->bzero()unless$selfref;
if($str=~s/
        ^
            \s*
            ( [+-]? )
            (0?b)?
            (
            [01]*
            ( _ [01]+ )*
            )
            \s*
            $
        //x
  ){my$sign=$1;
my$chrs=$3;
$chrs=~tr/_//d;
$chrs='0' unless CORE::length$chrs;
$self->{value}=$CALC->_from_bin('0b'.$chrs);
$self->{sign}=$sign eq '-'&&!$CALC->_is_zero($self->{value})?'-':'+';
return$self;}return$self->bnan();}sub from_bytes{my$self=shift;
my$selfref=ref$self;
my$class=$selfref||$self;
return if$selfref&&$self->modify('from_bytes');
Carp::croak("from_bytes() requires a newer version of the $CALC library.")unless$CALC->can('_from_bytes');
my$str=shift;
$self=$class->bzero()unless$selfref;
$self->{sign}='+';
$self->{value}=$CALC->_from_bytes($str);
return$self;}sub bzero{if(@_==0){unshift@_,__PACKAGE__;}my$self=shift;
my$selfref=ref$self;
my$class=$selfref||$self;
$self->import()if$IMPORT==0;
return if$selfref&&$self->modify('bzero');
$self=bless{},$class unless$selfref;
$self->{sign}='+';
$self->{value}=$CALC->_zero();
if(@_>0){if(@_>3){($self,$self->{_a},$self->{_p})=$self->_find_round_parameters(@_);}else{$self->{_a}=$_[0]if!defined$self->{_a}||(defined$_[0]&&$_[0]>$self->{_a});
$self->{_p}=$_[1]if!defined$self->{_p}||(defined$_[1]&&$_[1]>$self->{_p});}}return$self;}sub bone{if(@_==0||(defined($_[0])&&($_[0]eq '+'||$_[0]eq '-'))){unshift@_,__PACKAGE__;}my$self=shift;
my$selfref=ref$self;
my$class=$selfref||$self;
$self->import()if$IMPORT==0;
return if$selfref&&$self->modify('bone');
my$sign=shift;
$sign=defined$sign&&$sign=~/^\s*-/?"-":"+";
$self=bless{},$class unless$selfref;
$self->{sign}=$sign;
$self->{value}=$CALC->_one();
if(@_>0){if(@_>3){($self,$self->{_a},$self->{_p})=$self->_find_round_parameters(@_);}else{$self->{_a}=$_[0]if!defined$self->{_a}||(defined$_[0]&&$_[0]>$self->{_a});
$self->{_p}=$_[1]if!defined$self->{_p}||(defined$_[1]&&$_[1]>$self->{_p});}}return$self;}sub binf{if(@_==0||(defined($_[0])&&!ref($_[0])&&$_[0]=~/^\s*[+-](inf(inity)?)?\s*$/)){unshift@_,__PACKAGE__;}my$self=shift;
my$selfref=ref$self;
my$class=$selfref||$self;
{no strict 'refs';
if(${"${class}::_trap_inf"}){Carp::croak("Tried to create +-inf in $class->binf()");}}$self->import()if$IMPORT==0;
return if$selfref&&$self->modify('binf');
my$sign=shift;
$sign=defined$sign&&$sign=~/^\s*-/?"-":"+";
$self=bless{},$class unless$selfref;
$self->{sign}=$sign.'inf';
$self->{value}=$CALC->_zero();
return$self;}sub bnan{if(@_==0){unshift@_,__PACKAGE__;}my$self=shift;
my$selfref=ref($self);
my$class=$selfref||$self;
{no strict 'refs';
if(${"${class}::_trap_nan"}){Carp::croak("Tried to create NaN in $class->bnan()");}}$self->import()if$IMPORT==0;
return if$selfref&&$self->modify('bnan');
$self=bless{},$class unless$selfref;
$self->{sign}=$nan;
$self->{value}=$CALC->_zero();
return$self;}sub bpi{my($self,$n)=@_;
if(@_==1){$n=$self;
$self=$class;}$self=ref($self)if ref($self);
return$upgrade->new($n)if defined$upgrade;
$self->new(3);}sub copy{my$self=shift;
my$selfref=ref$self;
my$class=$selfref||$self;
$self=shift()unless$selfref;
my$copy=bless{},$class;
$copy->{sign}=$self->{sign};
$copy->{value}=$CALC->_copy($self->{value});
$copy->{_a}=$self->{_a}if exists$self->{_a};
$copy->{_p}=$self->{_p}if exists$self->{_p};
return$copy;}sub as_number{$_[0]->copy();}sub is_zero{my($class,$x)=ref($_[0])?(undef,$_[0]):objectify(1,@_);
return 0 if$x->{sign}!~/^\+$/;
$CALC->_is_zero($x->{value});}sub is_one{my($class,$x,$sign)=ref($_[0])?(undef,@_):objectify(1,@_);
$sign='+' if!defined$sign||$sign ne '-';
return 0 if$x->{sign}ne$sign;
$CALC->_is_one($x->{value});}sub is_finite{my$x=shift;
return$x->{sign}eq '+'||$x->{sign}eq '-';}sub is_inf{my($class,$x,$sign)=ref($_[0])?(undef,@_):objectify(1,@_);
if(defined$sign){$sign='[+-]inf' if$sign eq '';
$sign="[$1]inf" if$sign=~/^([+-])(inf)?$/;
return$x->{sign}=~/^$sign$/?1:0;}$x->{sign}=~/^[+-]inf$/?1:0;}sub is_nan{my($class,$x)=ref($_[0])?(undef,$_[0]):objectify(1,@_);
$x->{sign}eq$nan?1:0;}sub is_positive{my($class,$x)=ref($_[0])?(undef,$_[0]):objectify(1,@_);
return 1 if$x->{sign}eq '+inf';
($x->{sign}eq '+'&&!$x->is_zero())?1:0;}sub is_negative{my($class,$x)=ref($_[0])?(undef,$_[0]):objectify(1,@_);
$x->{sign}=~/^-/?1:0;}sub is_odd{my($class,$x)=ref($_[0])?(undef,$_[0]):objectify(1,@_);
return 0 if$x->{sign}!~/^[+-]$/;
$CALC->_is_odd($x->{value});}sub is_even{my($class,$x)=ref($_[0])?(undef,$_[0]):objectify(1,@_);
return 0 if$x->{sign}!~/^[+-]$/;
$CALC->_is_even($x->{value});}sub is_int{my($class,$x)=ref($_[0])?(undef,$_[0]):objectify(1,@_);
$x->{sign}=~/^[+-]$/?1:0;}sub bcmp{my($class,$x,$y)=ref($_[0])&&ref($_[0])eq ref($_[1])?(ref($_[0]),@_):objectify(2,@_);
return$upgrade->bcmp($x,$y)if defined$upgrade&&((!$x->isa($class))||(!$y->isa($class)));
if(($x->{sign}!~/^[+-]$/)||($y->{sign}!~/^[+-]$/)){return undef if(($x->{sign}eq$nan)||($y->{sign}eq$nan));
return 0 if$x->{sign}eq$y->{sign}&&$x->{sign}=~/^[+-]inf$/;
return+1 if$x->{sign}eq '+inf';
return-1 if$x->{sign}eq '-inf';
return-1 if$y->{sign}eq '+inf';
return+1;}return 1  if$x->{sign}eq '+'&&$y->{sign}eq '-';
return-1 if$x->{sign}eq '-'&&$y->{sign}eq '+';
if($x->{sign}eq '+'){return$CALC->_acmp($x->{value},$y->{value});}$CALC->_acmp($y->{value},$x->{value});}sub bacmp{my($class,$x,$y)=ref($_[0])&&ref($_[0])eq ref($_[1])?(ref($_[0]),@_):objectify(2,@_);
return$upgrade->bacmp($x,$y)if defined$upgrade&&((!$x->isa($class))||(!$y->isa($class)));
if(($x->{sign}!~/^[+-]$/)||($y->{sign}!~/^[+-]$/)){return undef if(($x->{sign}eq$nan)||($y->{sign}eq$nan));
return 0 if$x->{sign}=~/^[+-]inf$/&&$y->{sign}=~/^[+-]inf$/;
return 1 if$x->{sign}=~/^[+-]inf$/&&$y->{sign}!~/^[+-]inf$/;
return-1;}$CALC->_acmp($x->{value},$y->{value});}sub beq{my$self=shift;
my$selfref=ref$self;
my$class=$selfref||$self;
Carp::croak 'beq() is an instance method, not a class method' unless$selfref;
Carp::croak 'Wrong number of arguments for beq()' unless@_==1;
my$cmp=$self->bcmp(shift);
return defined($cmp)&&!$cmp;}sub bne{my$self=shift;
my$selfref=ref$self;
my$class=$selfref||$self;
Carp::croak 'bne() is an instance method, not a class method' unless$selfref;
Carp::croak 'Wrong number of arguments for bne()' unless@_==1;
my$cmp=$self->bcmp(shift);
return defined($cmp)&&!$cmp?'':1;}sub blt{my$self=shift;
my$selfref=ref$self;
my$class=$selfref||$self;
Carp::croak 'blt() is an instance method, not a class method' unless$selfref;
Carp::croak 'Wrong number of arguments for blt()' unless@_==1;
my$cmp=$self->bcmp(shift);
return defined($cmp)&&$cmp<0;}sub ble{my$self=shift;
my$selfref=ref$self;
my$class=$selfref||$self;
Carp::croak 'ble() is an instance method, not a class method' unless$selfref;
Carp::croak 'Wrong number of arguments for ble()' unless@_==1;
my$cmp=$self->bcmp(shift);
return defined($cmp)&&$cmp<=0;}sub bgt{my$self=shift;
my$selfref=ref$self;
my$class=$selfref||$self;
Carp::croak 'bgt() is an instance method, not a class method' unless$selfref;
Carp::croak 'Wrong number of arguments for bgt()' unless@_==1;
my$cmp=$self->bcmp(shift);
return defined($cmp)&&$cmp>0;}sub bge{my$self=shift;
my$selfref=ref$self;
my$class=$selfref||$self;
Carp::croak 'bge() is an instance method, not a class method' unless$selfref;
Carp::croak 'Wrong number of arguments for bge()' unless@_==1;
my$cmp=$self->bcmp(shift);
return defined($cmp)&&$cmp>=0;}sub bneg{my($class,$x)=ref($_[0])?(undef,$_[0]):objectify(1,@_);
return$x if$x->modify('bneg');
$x->{sign}=~tr/+-/-+/ unless($x->{sign}eq '+'&&$CALC->_is_zero($x->{value}));
$x;}sub babs{my($class,$x)=ref($_[0])?(undef,$_[0]):objectify(1,@_);
return$x if$x->modify('babs');
$x->{sign}=~s/^-/+/;
$x;}sub bsgn{my$self=shift;
return$self if$self->modify('bsgn');
return$self->bone("+")if$self->is_pos();
return$self->bone("-")if$self->is_neg();
return$self;}sub bnorm{my($class,$x)=ref($_[0])?(undef,$_[0]):objectify(1,@_);
$x;}sub binc{my($class,$x,$a,$p,$r)=ref($_[0])?(ref($_[0]),@_):objectify(1,@_);
return$x if$x->modify('binc');
if($x->{sign}eq '+'){$x->{value}=$CALC->_inc($x->{value});
return$x->round($a,$p,$r);}elsif($x->{sign}eq '-'){$x->{value}=$CALC->_dec($x->{value});
$x->{sign}='+' if$CALC->_is_zero($x->{value});
return$x->round($a,$p,$r);}$x->badd($class->bone(),$a,$p,$r);}sub bdec{my($class,$x,@r)=ref($_[0])?(ref($_[0]),@_):objectify(1,@_);
return$x if$x->modify('bdec');
if($x->{sign}eq '-'){$x->{value}=$CALC->_inc($x->{value});}else{return$x->badd($class->bone('-'),@r)unless$x->{sign}eq '+';
if($CALC->_is_zero($x->{value})){$x->{value}=$CALC->_one();
$x->{sign}='-';}else{$x->{value}=$CALC->_dec($x->{value});}}$x->round(@r);}sub badd{my($class,$x,$y,@r)=(ref($_[0]),@_);
if((!ref($_[0]))||(ref($_[0])ne ref($_[1]))){($class,$x,$y,@r)=objectify(2,@_);}return$x if$x->modify('badd');
return$upgrade->badd($upgrade->new($x),$upgrade->new($y),@r)if defined$upgrade&&((!$x->isa($class))||(!$y->isa($class)));
$r[3]=$y;
if($x->{sign}!~/^[+-]$/||$y->{sign}!~/^[+-]$/){return$x->bnan()if(($x->{sign}eq$nan)||($y->{sign}eq$nan));
if(($x->{sign}=~/^[+-]inf$/)&&($y->{sign}=~/^[+-]inf$/)){return$x if$x->{sign}eq$y->{sign};
return$x->bnan();}$x->{sign}=$y->{sign},return$x if$y->{sign}=~/^[+-]inf$/;
return$x;}my($sx,$sy)=($x->{sign},$y->{sign});
if($sx eq$sy){$x->{value}=$CALC->_add($x->{value},$y->{value});}else{my$a=$CALC->_acmp($y->{value},$x->{value});
if($a>0){$x->{value}=$CALC->_sub($y->{value},$x->{value},1);
$x->{sign}=$sy;}elsif($a==0){$x->{value}=$CALC->_zero();
$x->{sign}='+';}else{$x->{value}=$CALC->_sub($x->{value},$y->{value});}}$x->round(@r);}sub bsub{my($class,$x,$y,@r)=(ref($_[0]),@_);
if((!ref($_[0]))||(ref($_[0])ne ref($_[1]))){($class,$x,$y,@r)=objectify(2,@_);}return$x if$x->modify('bsub');
return$upgrade->new($x)->bsub($upgrade->new($y),@r)if defined$upgrade&&(!$x->isa($class)||!$y->isa($class));
return$x->round(@r)if$y->is_zero();
my$xsign=$x->{sign};
$y->{sign}=~tr/+-/-+/;
if($xsign ne$x->{sign}){return$x->bzero(@r)if$xsign=~/^[+-]$/;
return$x->bnan();}$x->badd($y,@r);
$y->{sign}=~tr/+-/-+/;
$x;}sub bmul{my($class,$x,$y,@r)=(ref($_[0]),@_);
if((!ref($_[0]))||(ref($_[0])ne ref($_[1]))){($class,$x,$y,@r)=objectify(2,@_);}return$x if$x->modify('bmul');
return$x->bnan()if(($x->{sign}eq$nan)||($y->{sign}eq$nan));
if(($x->{sign}=~/^[+-]inf$/)||($y->{sign}=~/^[+-]inf$/)){return$x->bnan()if$x->is_zero()||$y->is_zero();
return$x->binf()if($x->{sign}=~/^\+/&&$y->{sign}=~/^\+/);
return$x->binf()if($x->{sign}=~/^-/&&$y->{sign}=~/^-/);
return$x->binf('-');}return$upgrade->bmul($x,$upgrade->new($y),@r)if defined$upgrade&&!$y->isa($class);
$r[3]=$y;
$x->{sign}=$x->{sign}eq$y->{sign}?'+':'-';
$x->{value}=$CALC->_mul($x->{value},$y->{value});
$x->{sign}='+' if$CALC->_is_zero($x->{value});
$x->round(@r);}sub bmuladd{my($class,$x,$y,$z,@r)=objectify(3,@_);
return$x if$x->modify('bmuladd');
return$x->bnan()if(($x->{sign}eq$nan)||($y->{sign}eq$nan)||($z->{sign}eq$nan));
if(($x->{sign}=~/^[+-]inf$/)||($y->{sign}=~/^[+-]inf$/)){return$x->bnan()if$x->is_zero()||$y->is_zero();
return$x->binf()if($x->{sign}=~/^\+/&&$y->{sign}=~/^\+/);
return$x->binf()if($x->{sign}=~/^-/&&$y->{sign}=~/^-/);
return$x->binf('-');}if(($z->{sign}=~/^[+-]inf$/)){$x->{sign}=$z->{sign},return$x if$z->{sign}=~/^[+-]inf$/;}return$upgrade->bmuladd($x,$upgrade->new($y),$upgrade->new($z),@r)if defined$upgrade&&(!$y->isa($class)||!$z->isa($class)||!$x->isa($class));
$r[3]=$z;
$x->{sign}=$x->{sign}eq$y->{sign}?'+':'-';
$x->{value}=$CALC->_mul($x->{value},$y->{value});
$x->{sign}='+' if$CALC->_is_zero($x->{value});
my($sx,$sz)=($x->{sign},$z->{sign});
if($sx eq$sz){$x->{value}=$CALC->_add($x->{value},$z->{value});}else{my$a=$CALC->_acmp($z->{value},$x->{value});
if($a>0){$x->{value}=$CALC->_sub($z->{value},$x->{value},1);
$x->{sign}=$sz;}elsif($a==0){$x->{value}=$CALC->_zero();
$x->{sign}='+';}else{$x->{value}=$CALC->_sub($x->{value},$z->{value});}}$x->round(@r);}sub bdiv{my($class,$x,$y,@r)=(ref($_[0]),@_);
if((!ref($_[0]))||(ref($_[0])ne ref($_[1]))){($class,$x,$y,@r)=objectify(2,@_);}return$x if$x->modify('bdiv');
my$wantarray=wantarray;
if($x->is_nan()||$y->is_nan()){return$wantarray?($x->bnan(),$class->bnan()):$x->bnan();}if($y->is_zero()){my$rem;
if($wantarray){$rem=$x->copy();}if($x->is_zero()){$x->bnan();}else{$x->binf($x->{sign});}return$wantarray?($x,$rem):$x;}if($x->is_inf()){my$rem;
$rem=$class->bnan()if$wantarray;
if($y->is_inf()){$x->bnan();}else{my$sign=$x->bcmp(0)==$y->bcmp(0)?'+':'-';
$x->binf($sign);}return$wantarray?($x,$rem):$x;}if($y->is_inf()){my$rem;
if($x->is_zero()||$x->bcmp(0)==$y->bcmp(0)){$rem=$x->copy()if$wantarray;
$x->bzero();}else{$rem=$class->binf($y->{sign})if$wantarray;
$x->bone('-');}return$wantarray?($x,$rem):$x;}return$upgrade->bdiv($upgrade->new($x),$upgrade->new($y),@r)if defined$upgrade;
$r[3]=$y;
my$rem=$class->bzero();
my$xsign=$x->{sign};
my$ysign=$y->{sign};
$y->{sign}=~tr/+-/-+/;
my$same=$xsign ne$x->{sign};
$y->{sign}=$ysign;
if($same){$x->bone();}else{($x->{value},$rem->{value})=$CALC->_div($x->{value},$y->{value});
if($CALC->_is_zero($rem->{value})){if($xsign eq$ysign||$CALC->_is_zero($x->{value})){$x->{sign}='+';}else{$x->{sign}='-';}}else{if($xsign eq$ysign){$x->{sign}='+';}else{if($xsign eq '+'){$x->badd(1);}else{$x->bsub(1);}$x->{sign}='-';}}}$x->round(@r);
if($wantarray){unless($CALC->_is_zero($rem->{value})){if($xsign ne$ysign){$rem=$y->copy()->babs()->bsub($rem);}$rem->{sign}=$ysign;}$rem->{_a}=$x->{_a};
$rem->{_p}=$x->{_p};
$rem->round(@r);
return($x,$rem);}return$x;}sub btdiv{my($class,$x,$y,@r)=(ref($_[0]),@_);
if((!ref($_[0]))||(ref($_[0])ne ref($_[1]))){($class,$x,$y,@r)=objectify(2,@_);}return$x if$x->modify('btdiv');
my$wantarray=wantarray;
if($x->is_nan()||$y->is_nan()){return$wantarray?($x->bnan(),$class->bnan()):$x->bnan();}if($y->is_zero()){my$rem;
if($wantarray){$rem=$x->copy();}if($x->is_zero()){$x->bnan();}else{$x->binf($x->{sign});}return$wantarray?($x,$rem):$x;}if($x->is_inf()){my$rem;
$rem=$class->bnan()if$wantarray;
if($y->is_inf()){$x->bnan();}else{my$sign=$x->bcmp(0)==$y->bcmp(0)?'+':'-';
$x->binf($sign);}return$wantarray?($x,$rem):$x;}if($y->is_inf()){my$rem;
$rem=$x->copy()if$wantarray;
$x->bzero();
return$wantarray?($x,$rem):$x;}return$upgrade->btdiv($upgrade->new($x),$upgrade->new($y),@r)if defined$upgrade;
$r[3]=$y;
my$rem=$class->bzero();
my$xsign=$x->{sign};
my$ysign=$y->{sign};
$y->{sign}=~tr/+-/-+/;
my$same=$xsign ne$x->{sign};
$y->{sign}=$ysign;
if($same){$x->bone();}else{($x->{value},$rem->{value})=$CALC->_div($x->{value},$y->{value});
$x->{sign}=$xsign eq$ysign?'+':'-';
$x->{sign}='+' if$CALC->_is_zero($x->{value});
$x->round(@r);}if(wantarray){$rem->{sign}=$xsign;
$rem->{sign}='+' if$CALC->_is_zero($rem->{value});
$rem->{_a}=$x->{_a};
$rem->{_p}=$x->{_p};
$rem->round(@r);
return($x,$rem);}return$x;}sub bmod{my($class,$x,$y,@r)=(ref($_[0]),@_);
if((!ref($_[0]))||(ref($_[0])ne ref($_[1]))){($class,$x,$y,@r)=objectify(2,@_);}return$x if$x->modify('bmod');
$r[3]=$y;
if($x->is_nan()||$y->is_nan()){return$x->bnan();}if($y->is_zero()){return$x;}if($x->is_inf()){return$x->bnan();}if($y->is_inf()){if($x->is_zero()||$x->bcmp(0)==$y->bcmp(0)){return$x;}else{return$x->binf($y->sign());}}$x->{value}=$CALC->_mod($x->{value},$y->{value});
if($CALC->_is_zero($x->{value})){$x->{sign}='+';}else{$x->{value}=$CALC->_sub($y->{value},$x->{value},1)if($x->{sign}ne$y->{sign});
$x->{sign}=$y->{sign};}$x->round(@r);}sub btmod{my($class,$x,$y,@r)=(ref($_[0]),@_);
if((!ref($_[0]))||(ref($_[0])ne ref($_[1]))){($class,$x,$y,@r)=objectify(2,@_);}return$x if$x->modify('btmod');
if($x->is_nan()||$y->is_nan()){return$x->bnan();}if($y->is_zero()){return$x;}if($x->is_inf()){return$x->bnan();}if($y->is_inf()){return$x;}return$upgrade->btmod($upgrade->new($x),$upgrade->new($y),@r)if defined$upgrade;
$r[3]=$y;
my$xsign=$x->{sign};
my$ysign=$y->{sign};
$x->{value}=$CALC->_mod($x->{value},$y->{value});
$x->{sign}=$xsign;
$x->{sign}='+' if$CALC->_is_zero($x->{value});
$x->round(@r);
return$x;}sub bmodinv{my($class,$x,$y,@r)=(undef,@_);
if((!ref($_[0]))||(ref($_[0])ne ref($_[1]))){($class,$x,$y,@r)=objectify(2,@_);}return$x if$x->modify('bmodinv');
return$x->bnan()if($y->{sign}!~/^[+-]$/||$x->{sign}!~/^[+-]$/);
return$x->bnan()if$y->is_zero();
return$x->bzero()if($y->is_one()||$y->is_one('-'));
$x->bmod($y);
return$x->bnan()if$x->is_zero();
($x->{value},$x->{sign})=$CALC->_modinv($x->{value},$y->{value});
return$x->bnan()if!defined$x->{value};
$x->{sign}='+' unless defined$x->{sign};
$x->bneg()if$y->{sign}eq '-';
$x->bmod($y)if$x->{sign}ne$y->{sign};
return$x;}sub bmodpow{my($class,$num,$exp,$mod,@r)=objectify(3,@_);
return$num if$num->modify('bmodpow');
$num->bmodinv($mod)if($exp->{sign}eq '-');
return$num->bnan()if($num->{sign}=~/NaN|inf/||$exp->{sign}=~/NaN|inf/||$mod->{sign}=~/NaN|inf/);
if($mod->is_zero()){if($num->is_zero()){return$class->bnan();}else{return$num->copy();}}my$value=$CALC->_modpow($num->{value},$exp->{value},$mod->{value});
my$sign='+';
unless($CALC->_is_zero($value)){if($num->{sign}eq '-'&&$exp->is_odd()){if($mod->{sign}eq '-'){$sign='-';}else{my$mod=$CALC->_copy($mod->{value});
$value=$CALC->_sub($mod,$value);
$sign='+';}}else{if($mod->{sign}eq '-'){my$mod=$CALC->_copy($mod->{value});
$value=$CALC->_sub($mod,$value);
$sign='-';}}}$num->{value}=$value;
$num->{sign}=$sign;
return$num;}sub bpow{my($class,$x,$y,@r)=(ref($_[0]),@_);
if((!ref($_[0]))||(ref($_[0])ne ref($_[1]))){($class,$x,$y,@r)=objectify(2,@_);}return$x if$x->modify('bpow');
return$x->bnan()if$x->{sign}eq$nan||$y->{sign}eq$nan;
if(($x->{sign}=~/^[+-]inf$/)||($y->{sign}=~/^[+-]inf$/)){if(($x->{sign}=~/^[+-]inf$/)&&($y->{sign}=~/^[+-]inf$/)){return$x->bnan();}if($x->{sign}=~/^[+-]inf/){return$x->bnan()if$y->is_zero();
return$x->bzero()if$y->is_one('-')&&$x->is_negative();
return$x if$x->{sign}eq '+inf';
return$x if$y->is_odd();
return$x->babs();}return$x if$x->is_one();
return$x if$x->is_zero()&&$y->{sign}=~/^[+]/;
return$x->binf()if$x->is_zero();
return$x->bnan()if$x->is_one('-')&&$y->{sign}=~/^[-]/;
return$x->bzero()if$x->{sign}eq '-'&&$y->{sign}=~/^[-]/;
return$x->bnan()if$x->{sign}eq '-';
return$x->binf()if$y->{sign}=~/^[+]/;
return$x->bzero();}return$upgrade->bpow($upgrade->new($x),$y,@r)if defined$upgrade&&(!$y->isa($class)||$y->{sign}eq '-');
$r[3]=$y;
my$new_sign='+';
$new_sign=$y->is_odd()?'-':'+' if($x->{sign}ne '+');
return$x->binf()if$y->{sign}eq '-'&&$x->{sign}eq '+'&&$CALC->_is_zero($x->{value});
return$x->bnan()if$y->{sign}eq '-'&&!$CALC->_is_one($x->{value});
$x->{value}=$CALC->_pow($x->{value},$y->{value});
$x->{sign}=$new_sign;
$x->{sign}='+' if$CALC->_is_zero($y->{value});
$x->round(@r);}sub blog{my($class,$x,$base,@r);
if(!ref($_[0])&&$_[0]=~/^[A-Za-z]|::/){($class,$x,$base,@r)=defined$_[2]?objectify(2,@_):objectify(1,@_);}else{($class,$x,$base,@r)=defined$_[1]?objectify(2,@_):objectify(1,@_);}return$x if$x->modify('blog');
return$x->bnan()if$x->is_nan();
if(defined$base){$base=$class->new($base)unless ref$base;
if($base->is_nan()||$base->is_one()){return$x->bnan();}elsif($base->is_inf()||$base->is_zero()){return$x->bnan()if$x->is_inf()||$x->is_zero();
return$x->bzero();}elsif($base->is_negative()){return$x->bzero()if$x->is_one();
return$x->bone()if$x==$base;
return$x->bnan();}return$x->bone()if$x==$base;}return$x->binf('+')if$x->is_inf();
return$x->bnan()if$x->is_neg();
return$x->bzero()if$x->is_one();
return$x->binf('-')if$x->is_zero();
return$upgrade->blog($upgrade->new($x),$base,@r)if defined$upgrade;
if(!defined$base){require Math::BigFloat;
my$u=Math::BigFloat->blog(Math::BigFloat->new($x))->as_int();
$x->{value}=$u->{value};
$x->{sign}=$u->{sign};
return$x;}my($rc,$exact)=$CALC->_log_int($x->{value},$base->{value});
return$x->bnan()unless defined$rc;
$x->{value}=$rc;
$x->round(@r);}sub bexp{my($class,$x,@r)=ref($_[0])?(ref($_[0]),@_):objectify(1,@_);
return$x if$x->modify('bexp');
return$x->bnan()if$x->{sign}eq 'NaN';
return$x->bone()if$x->is_zero();
return$x          if$x->{sign}eq '+inf';
return$x->bzero()if$x->{sign}eq '-inf';
my$u;
{require Math::BigFloat unless defined$upgrade;
local$upgrade='Math::BigFloat' unless defined$upgrade;
$u=$upgrade->bexp($upgrade->new($x),@r);}if(defined$upgrade){$x=$u;}else{$u=$u->as_int();
$x->{value}=$u->{value};
$x->round(@r);}}sub bnok{my($class,$x,$y,@r)=(ref($_[0]),@_);
if((!ref($_[0]))||(ref($_[0])ne ref($_[1]))){($class,$x,$y,@r)=objectify(2,@_);}return$x if$x->modify('bnok');
return$x->bnan()if$x->{sign}eq 'NaN'||$y->{sign}eq 'NaN';
return$x->binf()if$x->{sign}eq '+inf';
my$cmp=$x->bacmp($y);
return$x->bzero()if$cmp<0||substr($y->{sign},0,1)eq"-";
if($CALC->can('_nok')){$x->{value}=$CALC->_nok($x->{value},$y->{value});}else{my$n=$x->{value};
my$k=$y->{value};
{my$twok=$CALC->_mul($CALC->_two(),$CALC->_copy($k));
if($CALC->_acmp($twok,$n)>0){$k=$CALC->_sub($CALC->_copy($n),$k);}}if($CALC->_is_zero($k)){$n=$CALC->_one();}else{my$n_orig=$CALC->_copy($n);
$CALC->_sub($n,$k);
$CALC->_inc($n);
my$f=$CALC->_copy($n);
$CALC->_inc($f);
my$d=$CALC->_two();
while($CALC->_acmp($f,$n_orig)<=0){$CALC->_mul($n,$f);
$CALC->_div($n,$d);
$CALC->_inc($f);
$CALC->_inc($d);}}$x->{value}=$n;}$x->round(@r);}sub bsin{my($class,$x,@r)=ref($_[0])?(undef,@_):objectify(1,@_);
return$x if$x->modify('bsin');
return$x->bnan()if$x->{sign}!~/^[+-]\z/;
return$upgrade->new($x)->bsin(@r)if defined$upgrade;
require Math::BigFloat;
my$t=Math::BigFloat->new($x)->bsin(@r)->as_int();
$x->bone()if$t->is_one();
$x->bzero()if$t->is_zero();
$x->round(@r);}sub bcos{my($class,$x,@r)=ref($_[0])?(undef,@_):objectify(1,@_);
return$x if$x->modify('bcos');
return$x->bnan()if$x->{sign}!~/^[+-]\z/;
return$upgrade->new($x)->bcos(@r)if defined$upgrade;
require Math::BigFloat;
my$t=Math::BigFloat->new($x)->bcos(@r)->as_int();
$x->bone()if$t->is_one();
$x->bzero()if$t->is_zero();
$x->round(@r);}sub batan{my($class,$x,@r)=ref($_[0])?(undef,@_):objectify(1,@_);
return$x if$x->modify('batan');
return$x->bnan()if$x->{sign}!~/^[+-]\z/;
return$upgrade->new($x)->batan(@r)if defined$upgrade;
my$t=Math::BigFloat->new($x)->batan(@r);
$x->{value}=$CALC->_new($x->as_int()->bstr());
$x->round(@r);}sub batan2{my($class,$y,$x,@r)=(ref($_[0]),@_);
if((!ref($_[0]))||(ref($_[0])ne ref($_[1]))){($class,$y,$x,@r)=objectify(2,@_);}return$y if$y->modify('batan2');
return$y->bnan()if($y->{sign}eq$nan)||($x->{sign}eq$nan);
if($x->is_inf()||$y->is_inf()){return$upgrade->new($y)->batan2($upgrade->new($x),@r)if defined$upgrade;
if($y->is_inf()){if($x->{sign}eq '-inf'){$y->bone(substr($y->{sign},0,1));
$y->bmul($class->new(2));}elsif($x->{sign}eq '+inf'){$y->bzero();}else{$y->bone(substr($y->{sign},0,1));}}else{if($x->{sign}eq '+inf'){$y->bzero();}else{$y->bone(substr($y->{sign},0,1));
$y->bmul($class->new(3));}}return$y;}return$upgrade->new($y)->batan2($upgrade->new($x),@r)if defined$upgrade;
require Math::BigFloat;
my$r=Math::BigFloat->new($y)->batan2(Math::BigFloat->new($x),@r)->as_int();
$x->{value}=$r->{value};
$x->{sign}=$r->{sign};
$x;}sub bsqrt{my($class,$x,@r)=ref($_[0])?(undef,@_):objectify(1,@_);
return$x if$x->modify('bsqrt');
return$x->bnan()if$x->{sign}!~/^\+/;
return$x if$x->{sign}eq '+inf';
return$upgrade->bsqrt($x,@r)if defined$upgrade;
$x->{value}=$CALC->_sqrt($x->{value});
$x->round(@r);}sub broot{my($class,$x,$y,@r)=(ref($_[0]),@_);
$y=$class->new(2)unless defined$y;
if((!ref($x))||(ref($x)ne ref($y))){($class,$x,$y,@r)=objectify(2,$class||$class,@_);}return$x if$x->modify('broot');
return$x->bnan()if$x->{sign}!~/^\+/||$y->is_zero()||$y->{sign}!~/^\+$/;
return$x->round(@r)if$x->is_zero()||$x->is_one()||$x->is_inf()||$y->is_one();
return$upgrade->new($x)->broot($upgrade->new($y),@r)if defined$upgrade;
$x->{value}=$CALC->_root($x->{value},$y->{value});
$x->round(@r);}sub bfac{my($class,$x,@r)=ref($_[0])?(undef,@_):objectify(1,@_);
return$x if$x->modify('bfac')||$x->{sign}eq '+inf';
return$x->bnan()if$x->{sign}ne '+';
$x->{value}=$CALC->_fac($x->{value});
$x->round(@r);}sub bdfac{my($class,$x,@r)=ref($_[0])?(undef,@_):objectify(1,@_);
return$x if$x->modify('bdfac')||$x->{sign}eq '+inf';
return$x->bnan()if$x->{sign}ne '+';
Carp::croak("bdfac() requires a newer version of the $CALC library.")unless$CALC->can('_dfac');
$x->{value}=$CALC->_dfac($x->{value});
$x->round(@r);}sub bfib{my($class,$x,@r)=objectify(1,@_);
Carp::croak("bfib() requires a newer version of the $CALC library.")unless$CALC->can('_fib');
return$x if$x->modify('bfib');
if(wantarray){return()if$x->is_nan();
Carp::croak("bfib() can't return an infinitely long list of numbers")if$x->is_inf();
my@values=$CALC->_fib($x->{value});
for(my$i=0;$i<$#values;++$i){my$fib=$class->bzero();
$fib->{value}=$values[$i];
$values[$i]=$fib;}$x->{value}=$values[-1];
$values[-1]=$x;
if($x->is_neg()){for(my$i=2;$i<=$#values;$i+=2){$values[$i]{sign}='-';}}@values=map{$_->round(@r)}@values;
return@values;}else{return$x if$x->modify('bdfac')||$x->is_inf('+');
return$x->bnan()if$x->is_nan()||$x->is_inf('-');
$x->{sign}=$x->is_neg()&&$x->is_even()?'-':'+';
$x->{value}=$CALC->_fib($x->{value});
return$x->round(@r);}}sub blucas{my($class,$x,@r)=objectify(1,@_);
Carp::croak("blucas() requires a newer version of the $CALC library.")unless$CALC->can('_lucas');
return$x if$x->modify('blucas');
if(wantarray){return()if$x->is_nan();
Carp::croak("blucas() can't return an infinitely long list of numbers")if$x->is_inf();
my@values=$CALC->_lucas($x->{value});
for(my$i=0;$i<$#values;++$i){my$lucas=$class->bzero();
$lucas->{value}=$values[$i];
$values[$i]=$lucas;}$x->{value}=$values[-1];
$values[-1]=$x;
if($x->is_neg()){for(my$i=2;$i<=$#values;$i+=2){$values[$i]{sign}='-';}}@values=map{$_->round(@r)}@values;
return@values;}else{return$x if$x->is_inf('+');
return$x->bnan()if$x->is_nan()||$x->is_inf('-');
$x->{sign}=$x->is_neg()&&$x->is_even()?'-':'+';
$x->{value}=$CALC->_lucas($x->{value});
return$x->round(@r);}}sub blsft{my($class,$x,$y,$b,@r)=(ref($_[0]),@_);
if((!ref($_[0]))||(ref($_[0])ne ref($_[1]))){($class,$x,$y,$b,@r)=objectify(2,@_);}return$x if$x->modify('blsft');
return$x->bnan()if($x->{sign}!~/^[+-]$/||$y->{sign}!~/^[+-]$/);
return$x->round(@r)if$y->is_zero();
$b=2 if!defined$b;
return$x->bnan()if$b<=0||$y->{sign}eq '-';
$x->{value}=$CALC->_lsft($x->{value},$y->{value},$b);
$x->round(@r);}sub brsft{my($class,$x,$y,$b,@r)=(ref($_[0]),@_);
if((!ref($_[0]))||(ref($_[0])ne ref($_[1]))){($class,$x,$y,$b,@r)=objectify(2,@_);}return$x if$x->modify('brsft');
return$x->bnan()if($x->{sign}!~/^[+-]$/||$y->{sign}!~/^[+-]$/);
return$x->round(@r)if$y->is_zero();
return$x->bzero(@r)if$x->is_zero();
$b=2 if!defined$b;
return$x->bnan()if$b<=0||$y->{sign}eq '-';
if(($x->{sign}eq '-')&&($b==2)){return$x->round(@r)if$x->is_one('-');
if(!$y->is_one()){$x->binc();
my$bin=$x->as_bin();
$bin=~s/^-0b//;
$bin=~tr/10/01/;
if($y>=CORE::length($bin)){$bin='0';}else{$bin=~s/.{$y}$//;
$bin='1'.$bin;
$bin=~tr/10/01/;}my$res=$class->new('0b'.$bin);
$res->binc();
$x->{value}=$res->{value};
return$x->round(@r);}$x->bdec();}$x->{value}=$CALC->_rsft($x->{value},$y->{value},$b);
$x->round(@r);}sub band{my($class,$x,$y,@r)=(ref($_[0]),@_);
if((!ref($_[0]))||(ref($_[0])ne ref($_[1]))){($class,$x,$y,@r)=objectify(2,@_);}return$x if$x->modify('band');
$r[3]=$y;
return$x->bnan()if($x->{sign}!~/^[+-]$/||$y->{sign}!~/^[+-]$/);
my$sx=$x->{sign}eq '+'?1:-1;
my$sy=$y->{sign}eq '+'?1:-1;
if($sx==1&&$sy==1){$x->{value}=$CALC->_and($x->{value},$y->{value});
return$x->round(@r);}if($CAN{signed_and}){$x->{value}=$CALC->_signed_and($x->{value},$y->{value},$sx,$sy);
return$x->round(@r);}require$EMU_LIB;
__emu_band($class,$x,$y,$sx,$sy,@r);}sub bior{my($class,$x,$y,@r)=(ref($_[0]),@_);
if((!ref($_[0]))||(ref($_[0])ne ref($_[1]))){($class,$x,$y,@r)=objectify(2,@_);}return$x if$x->modify('bior');
$r[3]=$y;
return$x->bnan()if($x->{sign}!~/^[+-]$/||$y->{sign}!~/^[+-]$/);
my$sx=$x->{sign}eq '+'?1:-1;
my$sy=$y->{sign}eq '+'?1:-1;
if($sx==1&&$sy==1){$x->{value}=$CALC->_or($x->{value},$y->{value});
return$x->round(@r);}if($CAN{signed_or}){$x->{value}=$CALC->_signed_or($x->{value},$y->{value},$sx,$sy);
return$x->round(@r);}require$EMU_LIB;
__emu_bior($class,$x,$y,$sx,$sy,@r);}sub bxor{my($class,$x,$y,@r)=(ref($_[0]),@_);
if((!ref($_[0]))||(ref($_[0])ne ref($_[1]))){($class,$x,$y,@r)=objectify(2,@_);}return$x if$x->modify('bxor');
$r[3]=$y;
return$x->bnan()if($x->{sign}!~/^[+-]$/||$y->{sign}!~/^[+-]$/);
my$sx=$x->{sign}eq '+'?1:-1;
my$sy=$y->{sign}eq '+'?1:-1;
if($sx==1&&$sy==1){$x->{value}=$CALC->_xor($x->{value},$y->{value});
return$x->round(@r);}if($CAN{signed_xor}){$x->{value}=$CALC->_signed_xor($x->{value},$y->{value},$sx,$sy);
return$x->round(@r);}require$EMU_LIB;
__emu_bxor($class,$x,$y,$sx,$sy,@r);}sub bnot{my($class,$x,$a,$p,$r)=ref($_[0])?(undef,@_):objectify(1,@_);
return$x if$x->modify('bnot');
$x->binc()->bneg();}sub round{my($self,$a,$p,$r,@args)=@_;
my$class=ref($self);
no strict 'refs';
if(!defined$a){foreach($self,@args){$a=$_->{_a}if(defined$_->{_a})&&(!defined$a||$_->{_a}<$a);}}if(!defined$p){foreach($self,@args){$p=$_->{_p}if(defined$_->{_p})&&(!defined$p||$_->{_p}>$p);}}$a=${"$class\::accuracy"}unless defined$a;
$p=${"$class\::precision"}unless defined$p;
$a=undef if defined$a&&$a==0;
return$self unless defined$a||defined$p;
return$self->bnan()if defined$a&&defined$p;
$r=${"$class\::round_mode"}unless defined$r;
if($r!~/^(even|odd|[+-]inf|zero|trunc|common)$/){Carp::croak("Unknown round mode '$r'");}if(defined$a){$self->bround(int($a),$r)if!defined$self->{_a}||$self->{_a}>=$a;}else{$self->bfround(int($p),$r)if!defined$self->{_p}||$self->{_p}<=$p;}$self;}sub bround{my$x=shift;
$x=$class->new($x)unless ref$x;
my($scale,$mode)=$x->_scale_a(@_);
return$x if!defined$scale||$x->modify('bround');
if($x->is_zero()||$scale==0){$x->{_a}=$scale if!defined$x->{_a}||$x->{_a}>$scale;
return$x;}return$x if$x->{sign}!~/^[+-]$/;
my$len=$x->length();
$scale=$scale->numify()if ref($scale);
if(($scale<0&&$scale<-$len-1)||($scale>=$len)){$x->{_a}=$scale if!defined$x->{_a}||$x->{_a}>$scale;
return$x;}my($pad,$digit_round,$digit_after);
$pad=$len-$scale;
$pad=abs($scale-1)if$scale<0;
my$xs=$CALC->_str($x->{value});
my$pl=-$pad-1;
$digit_round='0';
$digit_round=substr($xs,$pl,1)if$pad<=$len;
$pl++;
$pl++ if$pad>=$len;
$digit_after='0';
$digit_after=substr($xs,$pl,1)if$pad>0;
my$round_up=1;
$round_up-- if($mode eq 'trunc')||($digit_after=~/[01234]/)||($digit_after eq '5')&&($x->_scan_for_nonzero($pad,$xs,$len)==0)&&(($mode eq 'even')&&($digit_round=~/[24680]/)||($mode eq 'odd')&&($digit_round=~/[13579]/)||($mode eq '+inf')&&($x->{sign}eq '-')||($mode eq '-inf')&&($x->{sign}eq '+')||($mode eq 'zero'));
my$put_back=0;
if(($pad>0)&&($pad<=$len)){substr($xs,-$pad,$pad)='0' x$pad;
$put_back=1;}elsif($pad>$len){$x->bzero();}if($round_up){$put_back=1;
$pad=$len,$xs='0' x$pad if$scale<0;
my$c=0;
$pad++;
while($pad<=$len){$c=substr($xs,-$pad,1)+1;
$c='0' if$c eq '10';
substr($xs,-$pad,1)=$c;
$pad++;
last if$c!=0;}$xs='1'.$xs if$c==0;}$x->{value}=$CALC->_new($xs)if$put_back==1;
$x->{_a}=$scale if$scale>=0;
if($scale<0){$x->{_a}=$len+$scale;
$x->{_a}=0 if$scale<-$len;}$x;}sub bfround{my$x=shift;
my$class=ref($x)||$x;
$x=$class->new($x)unless ref$x;
my($scale,$mode)=$x->_scale_p(@_);
return$x if!defined$scale||$x->modify('bfround');
$x->bround($x->length()-$scale,$mode)if$scale>0;
delete$x->{_a};
$x->{_p}=$scale;
$x;}sub fround{my$x=shift;
$x=$class->new($x)unless ref$x;
$x->bround(@_);}sub bfloor{my($class,$x,@r)=ref($_[0])?(undef,@_):objectify(1,@_);
$x->round(@r);}sub bceil{my($class,$x,@r)=ref($_[0])?(undef,@_):objectify(1,@_);
$x->round(@r);}sub bint{my($class,$x,@r)=ref($_[0])?(undef,@_):objectify(1,@_);
$x->round(@r);}sub bgcd{my($class,@args)=objectify(0,@_);
my$x=shift@args;
$x=ref($x)&&$x->isa($class)?$x->copy():$class->new($x);
return$class->bnan()if$x->{sign}!~/^[+-]$/;
while(@args){my$y=shift@args;
$y=$class->new($y)unless ref($y)&&$y->isa($class);
return$class->bnan()if$y->{sign}!~/^[+-]$/;
$x->{value}=$CALC->_gcd($x->{value},$y->{value});
last if$CALC->_is_one($x->{value});}return$x->babs();}sub blcm{my($class,@args)=objectify(0,@_);
my$x=shift@args;
$x=ref($x)&&$x->isa($class)?$x->copy():$class->new($x);
return$class->bnan()if$x->{sign}!~/^[+-]$/;
while(@args){my$y=shift@args;
$y=$class->new($y)unless ref($y)&&$y->isa($class);
return$x->bnan()if$y->{sign}!~/^[+-]$/;
$x->{value}=$CALC->_lcm($x->{value},$y->{value});}return$x->babs();}sub sign{my($class,$x)=ref($_[0])?(undef,$_[0]):objectify(1,@_);
$x->{sign};}sub digit{my($class,$x,$n)=ref($_[0])?(undef,@_):objectify(1,@_);
$n=$n->numify()if ref($n);
$CALC->_digit($x->{value},$n||0);}sub length{my($class,$x)=ref($_[0])?(undef,$_[0]):objectify(1,@_);
my$e=$CALC->_len($x->{value});
wantarray?($e,0):$e;}sub exponent{my($class,$x)=ref($_[0])?(ref($_[0]),$_[0]):objectify(1,@_);
if($x->{sign}!~/^[+-]$/){my$s=$x->{sign};
$s=~s/^[+-]//;
return$class->new($s);}return$class->bzero()if$x->is_zero();
$class->new($CALC->_zeros($x->{value}));}sub mantissa{my($class,$x)=ref($_[0])?(ref($_[0]),$_[0]):objectify(1,@_);
if($x->{sign}!~/^[+-]$/){return$class->new($x->{sign});}my$m=$x->copy();
delete$m->{_p};
delete$m->{_a};
my$zeros=$CALC->_zeros($m->{value});
$m->brsft($zeros,10)if$zeros!=0;
$m;}sub parts{my($class,$x)=ref($_[0])?(undef,$_[0]):objectify(1,@_);
($x->mantissa(),$x->exponent());}sub sparts{my$self=shift;
my$class=ref$self;
Carp::croak("sparts() is an instance method, not a class method")unless$class;
if($self->is_nan()){my$mant=$self->copy();
return$mant unless wantarray;
my$expo=$class->bnan();
return($mant,$expo);}if($self->is_inf()){my$mant=$self->copy();
return$mant unless wantarray;
my$expo=$class->binf('+');
return($mant,$expo);}my$mant=$self->copy();
my$nzeros=$CALC->_zeros($mant->{value});
$mant->brsft($nzeros,10)if$nzeros!=0;
return$mant unless wantarray;
my$expo=$class->new($nzeros);
return($mant,$expo);}sub nparts{my$self=shift;
my$class=ref$self;
Carp::croak("nparts() is an instance method, not a class method")unless$class;
if($self->is_nan()){my$mant=$self->copy();
return$mant unless wantarray;
my$expo=$class->bnan();
return($mant,$expo);}if($self->is_inf()){my$mant=$self->copy();
return$mant unless wantarray;
my$expo=$class->binf('+');
return($mant,$expo);}my($mant,$expo)=$self->sparts();
if($mant->bcmp(0)){my($ndigtot,$ndigfrac)=$mant->length();
my$expo10adj=$ndigtot-$ndigfrac-1;
if($expo10adj!=0){return$upgrade->new($self)->nparts()if$upgrade;
$mant->bnan();
return$mant unless wantarray;
$expo->badd($expo10adj);
return($mant,$expo);}}return$mant unless wantarray;
return($mant,$expo);}sub eparts{my$self=shift;
my$class=ref$self;
Carp::croak("eparts() is an instance method, not a class method")unless$class;
return$self->sparts()if$self->is_nan()||$self->is_inf();
my($mant,$expo)=$self->sparts();
if($mant->bcmp(0)){my$ndigmant=$mant->length();
$expo->badd($ndigmant);
my$c=$expo->copy()->bdec()->bmod(3)->binc();
$expo->bsub($c);
if($ndigmant>$c){return$upgrade->new($self)->eparts()if$upgrade;
$mant->bnan();
return$mant unless wantarray;
return($mant,$expo);}$mant->blsft($c-$ndigmant,10);}return$mant unless wantarray;
return($mant,$expo);}sub dparts{my$self=shift;
my$class=ref$self;
Carp::croak("dparts() is an instance method, not a class method")unless$class;
my$int=$self->copy();
return$int unless wantarray;
my$frc=$class->bzero();
return($int,$frc);}sub bstr{my($class,$x)=ref($_[0])?(undef,$_[0]):objectify(1,@_);
if($x->{sign}ne '+'&&$x->{sign}ne '-'){return$x->{sign}unless$x->{sign}eq '+inf';
return 'inf';}my$str=$CALC->_str($x->{value});
return$x->{sign}eq '-'?"-$str":$str;}sub bsstr{my($class,$x)=ref($_[0])?(undef,$_[0]):objectify(1,@_);
if($x->{sign}ne '+'&&$x->{sign}ne '-'){return$x->{sign}unless$x->{sign}eq '+inf';
return 'inf';}my($m,$e)=$x->parts();
my$str=$CALC->_str($m->{value}).'e+'.$CALC->_str($e->{value});
return$x->{sign}eq '-'?"-$str":$str;}sub bnstr{my$x=shift;
if($x->{sign}ne '+'&&$x->{sign}ne '-'){return$x->{sign}unless$x->{sign}eq '+inf';
return 'inf';}return$x->bstr()if$x->is_nan()||$x->is_inf();
my($mant,$expo)=$x->parts();
my$fracpos=$mant->length()-1;
if($fracpos==0){my$str=$CALC->_str($mant->{value})."e+".$CALC->_str($expo->{value});
return$x->{sign}eq '-'?"-$str":$str;}$expo+=$fracpos;
my$mantstr=$CALC->_str($mant->{value});
substr($mantstr,-$fracpos,0)='.';
my$str=$mantstr.'e+'.$CALC->_str($expo->{value});
return$x->{sign}eq '-'?"-$str":$str;}sub bestr{my$x=shift;
if($x->{sign}ne '+'&&$x->{sign}ne '-'){return$x->{sign}unless$x->{sign}eq '+inf';
return 'inf';}my($mant,$expo)=$x->parts();
my$sign=$mant->sign();
$mant->babs();
my$mantstr=$CALC->_str($mant->{value});
my$mantlen=CORE::length($mantstr);
my$dotidx=1;
$expo+=$mantlen-1;
my$c=$expo->copy()->bmod(3);
$expo-=$c;
$dotidx+=$c;
if($mantlen<$dotidx){$mantstr.="0" x($dotidx-$mantlen);}elsif($mantlen>$dotidx){substr($mantstr,$dotidx,0)=".";}my$str=$mantstr.'e+'.$CALC->_str($expo->{value});
return$sign eq"-"?"-$str":$str;}sub bdstr{my$x=shift;
if($x->{sign}ne '+'&&$x->{sign}ne '-'){return$x->{sign}unless$x->{sign}eq '+inf';
return 'inf';}my$str=$CALC->_str($x->{value});
return$x->{sign}eq '-'?"-$str":$str;}sub to_hex{my$x=shift;
$x=$class->new($x)if!ref($x);
return$x->bstr()if$x->{sign}!~/^[+-]$/;
my$hex=$CALC->_to_hex($x->{value});
return$x->{sign}eq '-'?"-$hex":$hex;}sub to_oct{my$x=shift;
$x=$class->new($x)if!ref($x);
return$x->bstr()if$x->{sign}!~/^[+-]$/;
my$oct=$CALC->_to_oct($x->{value});
return$x->{sign}eq '-'?"-$oct":$oct;}sub to_bin{my$x=shift;
$x=$class->new($x)if!ref($x);
return$x->bstr()if$x->{sign}!~/^[+-]$/;
my$bin=$CALC->_to_bin($x->{value});
return$x->{sign}eq '-'?"-$bin":$bin;}sub to_bytes{my$x=shift;
$x=$class->new($x)if!ref($x);
Carp::croak("to_bytes() requires a finite, non-negative integer")if$x->is_neg()||!$x->is_int();
Carp::croak("to_bytes() requires a newer version of the $CALC library.")unless$CALC->can('_to_bytes');
return$CALC->_to_bytes($x->{value});}sub as_hex{my$x=shift;
$x=$class->new($x)if!ref($x);
return$x->bstr()if$x->{sign}!~/^[+-]$/;
my$hex=$CALC->_as_hex($x->{value});
return$x->{sign}eq '-'?"-$hex":$hex;}sub as_oct{my$x=shift;
$x=$class->new($x)if!ref($x);
return$x->bstr()if$x->{sign}!~/^[+-]$/;
my$oct=$CALC->_as_oct($x->{value});
return$x->{sign}eq '-'?"-$oct":$oct;}sub as_bin{my$x=shift;
$x=$class->new($x)if!ref($x);
return$x->bstr()if$x->{sign}!~/^[+-]$/;
my$bin=$CALC->_as_bin($x->{value});
return$x->{sign}eq '-'?"-$bin":$bin;}*as_bytes=\&to_bytes;
sub numify{my$x=shift;
$x=$class->new($x)unless ref$x;
if($x->is_nan()){require Math::Complex;
my$inf=Math::Complex::Inf();
return$inf-$inf;}if($x->is_inf()){require Math::Complex;
my$inf=Math::Complex::Inf();
return$x->is_negative()?-$inf:$inf;}my$num=0+$CALC->_num($x->{value});
return$x->{sign}eq '-'?-$num:$num;}sub objectify{return(ref($_[1]),$_[1])if@_==2&&($_[0]||0)==1&&ref($_[1]);
unless(wantarray){Carp::croak("${class}::objectify() needs list context");}my$count=shift;
my@a=@_;
my$class;
if(ref($a[0])){$class=ref($a[0]);}elsif($a[0]=~/^[A-Z].*::/){$class=shift@a;}else{$class=__PACKAGE__;}$count||=@a;
unshift@a,$class;
no strict 'refs';
my$up=${"$a[0]::upgrade"};
my$down;
if(defined${"$a[0]::downgrade"}){$down=${"$a[0]::downgrade"};
${"$a[0]::downgrade"}=undef;}for my $i(1..$count){my$ref=ref$a[$i];
unless($ref){$a[$i]=$a[0]->new($a[$i]);
next;}next if$ref->isa($a[0]);
if(defined$up&&$ref->isa($up)){next;}my$recheck=0;
if($a[0]->isa('Math::BigInt')){if($a[$i]->can('as_int')){$a[$i]=$a[$i]->as_int();
$recheck=1;}elsif($a[$i]->can('as_number')){$a[$i]=$a[$i]->as_number();
$recheck=1;}}elsif($a[0]->isa('Math::BigFloat')){if($a[$i]->can('as_float')){$a[$i]=$a[$i]->as_float();
$recheck=$1;}}if($recheck){$ref=ref($a[$i]);
unless($ref){$a[$i]=$a[0]->new($a[$i]);
next;}next if$ref->isa($a[0]);}$a[$i]=$a[0]->new($a[$i]);}${"$a[0]::downgrade"}=$down;
return@a;}sub import{my$class=shift;
$IMPORT++;
my@a;
my$l=scalar@_;
my$warn_or_die=0;
for(my$i=0;$i<$l;$i++){if($_[$i]eq ':constant'){overload::constant integer=>sub{$class->new(shift)},binary=>sub{$class->new(shift)};}elsif($_[$i]eq 'upgrade'){$upgrade=$_[$i+1];
$i++;}elsif($_[$i]=~/^(lib|try|only)\z/){$CALC=$_[$i+1]||'';
$warn_or_die=1 if$_[$i]eq 'lib';
$warn_or_die=2 if$_[$i]eq 'only';
$i++;}else{push@a,$_[$i];}}if(@a>0){require Exporter;
$class->SUPER::import(@a);
$class->export_to_level(1,$class,@a);}my@c=split/\s*,\s*/,$CALC||'';
foreach(@c){$_=~tr/a-zA-Z0-9://cd;}push@c,\'Calc' if$warn_or_die<2;
$CALC='';
foreach my $l(@c){my$lib=$l;
$lib=$$l if ref($l);
next if($lib||'')eq '';
$lib='Math::BigInt::'.$lib if$lib!~/^Math::BigInt/i;
$lib=~s/\.pm$//;
if($]<5.006){my@parts=split/::/,$lib;
my$file=pop@parts;
$file.='.pm';
require File::Spec;
$file=File::Spec->catfile(@parts,$file);
eval{require"$file";
$lib->import(@c);}}else{eval"use $lib qw/@c/;";}if($@eq ''){my$ok=1;
if($lib->can('_api_version')&&$lib->_api_version()>=1.0){$ok=0;
for my $method(qw/
one two ten
str num
add mul div sub dec inc
acmp len digit is_one is_zero is_even is_odd
is_two is_ten
zeros new copy check
from_hex from_oct from_bin as_hex as_bin as_oct
rsft lsft xor and or
mod sqrt root fac pow modinv modpow log_int gcd
/){if(!$lib->can("_$method")){if(($WARN{$lib}||0)<2){Carp::carp("$lib is missing method '_$method'");
$WARN{$lib}=1;}$ok++;
last;}}}if($ok==0){$CALC=$lib;
if($warn_or_die>0&&ref($l)){my$msg="Math::BigInt: couldn't load specified"." math lib(s), fallback to $lib";
Carp::carp($msg)if$warn_or_die==1;
Carp::croak($msg)if$warn_or_die==2;}last;}else{if(($WARN{$lib}||0)<2){my$ver=eval"\$$lib\::VERSION"||'unknown';
Carp::carp("Cannot load outdated $lib v$ver, please upgrade");
$WARN{$lib}=2;}}}}if($CALC eq ''){if($warn_or_die==2){Carp::croak("Couldn't load specified math lib(s)"." and fallback disallowed");}else{Carp::croak("Couldn't load any math lib(s), not even fallback to Calc.pm");}}foreach my $class(keys%CALLBACKS){&{$CALLBACKS{$class}}($CALC);}%CAN=();
for my $method(qw/ signed_and signed_or signed_xor /){$CAN{$method}=$CALC->can("_$method")?1:0;}}sub _register_callback{my($class,$callback)=@_;
if(ref($callback)ne 'CODE'){Carp::croak("$callback is not a coderef");}$CALLBACKS{$class}=$callback;}sub _split_dec_string{my$str=shift;
if($str=~s/
        ^

            # leading whitespace
            ( \s* )

            # optional sign
            ( [+-]? )

            # significand
            (
            \d+ (?: _ \d+ )*
            (?:
            \.
            (?: \d+ (?: _ \d+ )* )?
            )?
            |
            \.
            \d+ (?: _ \d+ )*
            )

            # optional exponent
            (?:
            [Ee]
            ( [+-]? )
            ( \d+ (?: _ \d+ )* )
            )?

            # trailing stuff
            ( \D .*? )?

            \z
        //x
  ){my$leading=$1;
my$significand_sgn=$2||'+';
my$significand_abs=$3;
my$exponent_sgn=$4||'+';
my$exponent_abs=$5||'0';
my$trailing=$6;
$significand_abs=~tr/_//d;
$exponent_abs=~tr/_//d;
$significand_abs=~s/^0+(.)/$1/;
$exponent_abs=~s/^0+(.)/$1/;
my$idx=index$significand_abs,'.';
if($idx>-1){$significand_abs=~s/0+\z//;
substr($significand_abs,$idx,1)='';
my$exponent=$exponent_sgn.$exponent_abs;
$exponent.=$idx-CORE::length($significand_abs);
$exponent_abs=abs$exponent;
$exponent_sgn=$exponent<0?'-':'+';}return($leading,$significand_sgn,$significand_abs,$exponent_sgn,$exponent_abs,$trailing);}return undef;}sub _split{my$x=shift;
$x=~s/^\s*([-]?)0*([0-9])/$1$2/g;
$x=~s/^\s+//;
$x=~s/\s+$//g;
if($x=~/^[+-]?[0-9]+\z/){$x=~s/^([+-])0*([0-9])/$2/;
my$sign=$1||'+';
return(\$sign,\$x,\'',\'',\0);}return if$x!~/^[+-]?(\.?[0-9]|0b[0-1]|0x[0-9a-fA-F])/;
return Math::BigInt->from_hex($x)if$x=~/^[+-]?0x/;
return Math::BigInt->from_bin($x)if$x=~/^[+-]?0b/;
$x=~s/([0-9])_([0-9])/$1$2/g;
$x=~s/([0-9])_([0-9])/$1$2/g;
my($m,$e,$last)=split/[Ee]/,$x;
return if defined$last;
$e='0' if!defined$e||$e eq"";
my($es,$ev,$mis,$miv,$mfv);
if($e=~/^([+-]?)0*([0-9]+)$/){$es=$1;
$ev=$2;
return if$m eq '.'||$m eq '';
my($mi,$mf,$lastf)=split/\./,$m;
return if defined$lastf;
$mi='0' if!defined$mi;
$mi.='0' if$mi=~/^[\-\+]?$/;
$mf='0' if!defined$mf||$mf eq '';
if($mi=~/^([+-]?)0*([0-9]+)$/){$mis=$1||'+';
$miv=$2;
return unless($mf=~/^([0-9]*?)0*$/);
$mfv=$1;
$ev=0 if$miv eq '0'&&$mfv eq '';
return(\$mis,\$miv,\$mfv,\$es,\$ev);}}return;}sub _trailing_zeros{my$x=shift;
$x=$class->new($x)unless ref$x;
return 0 if$x->{sign}!~/^[+-]$/;
$CALC->_zeros($x->{value});}sub _scan_for_nonzero{my($x,$pad,$xs,$len)=@_;
return 0 if$len==1;
my$follow=$pad-1;
return 0 if$follow>$len||$follow<1;
substr($xs,-$follow)=~/[^0]/?1:0;}sub _find_round_parameters{my($self,$a,$p,$r,@args)=@_;
my$class=ref($self);
no strict 'refs';
$a=$a->can('numify')?$a->numify():"$a" if defined$a&&ref($a);
$p=$p->can('numify')?$p->numify():"$p" if defined$p&&ref($p);
if(!defined$a){foreach($self,@args){$a=$_->{_a}if(defined$_->{_a})&&(!defined$a||$_->{_a}<$a);}}if(!defined$p){foreach($self,@args){$p=$_->{_p}if(defined$_->{_p})&&(!defined$p||$_->{_p}>$p);}}$a=${"$class\::accuracy"}unless defined$a;
$p=${"$class\::precision"}unless defined$p;
$a=undef if defined$a&&$a==0;
return($self)unless defined$a||defined$p;
return($self->bnan())if defined$a&&defined$p;
$r=${"$class\::round_mode"}unless defined$r;
if($r!~/^(even|odd|[+-]inf|zero|trunc|common)$/){Carp::croak("Unknown round mode '$r'");}$a=int($a)if defined$a;
$p=int($p)if defined$p;
($self,$a,$p,$r);}sub modify (){0;}1;
package Math::BigInt::Calc;
use 5.006001;
use strict;
use warnings;
use Carp qw< carp croak >;
Math::BigInt::Lib->import();
our$VERSION='1.999813';
our@ISA=('Math::BigInt::Lib');
sub _api_version (){2;}my($BASE,$BASE_LEN,$RBASE,$MAX_VAL);
my($AND_BITS,$XOR_BITS,$OR_BITS);
my($AND_MASK,$XOR_MASK,$OR_MASK);
sub _base_len{my($class,$b,$int)=@_;
if(defined$b){undef&_mul;
undef&_div;
if($]>=5.008&&$int&&$b>7){$BASE_LEN=$b;
*_mul=\&_mul_use_div_64;
*_div=\&_div_use_div_64;
$BASE=int("1e".$BASE_LEN);
$MAX_VAL=$BASE-1;
return$BASE_LEN unless wantarray;
return($BASE_LEN,$BASE,$AND_BITS,$XOR_BITS,$OR_BITS,$BASE_LEN,$MAX_VAL);}$BASE_LEN=$b+1;
my$caught=0;
while(--$BASE_LEN>5){$BASE=int("1e".$BASE_LEN);
$RBASE=abs('1e-'.$BASE_LEN);
$caught=0;
$caught+=1 if(int($BASE*$RBASE)!=1);
$caught+=2 if(int($BASE/$BASE)!=1);
last if$caught!=3;}$BASE=int("1e".$BASE_LEN);
$RBASE=abs('1e-'.$BASE_LEN);
$MAX_VAL=$BASE-1;
if($caught==2){*_mul=\&_mul_use_mul;
*_div=\&_div_use_mul;}else{*_mul=\&_mul_use_div;
*_div=\&_div_use_div;}}return$BASE_LEN unless wantarray;
return($BASE_LEN,$BASE,$AND_BITS,$XOR_BITS,$OR_BITS,$BASE_LEN,$MAX_VAL);}sub _new{my($class,$str)=@_;
my$input_len=length($str)-1;
return bless[$str],$class if$input_len<$BASE_LEN;
my$format="a".(($input_len%$BASE_LEN)+1);
$format.=$]<5.008?"a$BASE_LEN" x int($input_len/$BASE_LEN):"(a$BASE_LEN)*";
my$self=[reverse(map{0+$_}unpack($format,$str))];
return bless$self,$class;}BEGIN{my($e,$num)=3;
do{$num='9' x ++$e;
$num*=$num+1;}while$num=~/9{$e}0{$e}/;
$e--;
$e=5 if$^O=~/^uts/;
$e=5 if$^O=~/^unicos/;
my$int=0;
if($e>7){use integer;
my$e1=7;
$num=7;
do{$num=('9' x ++$e1)+0;
$num*=$num+1;}while("$num"=~/9{$e1}0{$e1}/);
$e1--;
if($e1>7){$int=1;
$e=$e1;}}__PACKAGE__->_base_len($e,$int);
use integer;
local$^W=0;
$AND_BITS=15;
$XOR_BITS=15;
$OR_BITS=15;
my$max=16;
while(2**$max<$BASE){$max++;}{no integer;
$max=16 if$]<5.006;}my($x,$y,$z);
do{$AND_BITS++;
$x=CORE::oct('0b'.'1' x$AND_BITS);
$y=$x&$x;
$z=(2**$AND_BITS)-1;}while($AND_BITS<$max&&$x==$z&&$y==$x);
$AND_BITS--;
do{$XOR_BITS++;
$x=CORE::oct('0b'.'1' x$XOR_BITS);
$y=$x^0;
$z=(2**$XOR_BITS)-1;}while($XOR_BITS<$max&&$x==$z&&$y==$x);
$XOR_BITS--;
do{$OR_BITS++;
$x=CORE::oct('0b'.'1' x$OR_BITS);
$y=$x|$x;
$z=(2**$OR_BITS)-1;}while($OR_BITS<$max&&$x==$z&&$y==$x);
$OR_BITS--;
$AND_MASK=__PACKAGE__->_new((2**$AND_BITS));
$XOR_MASK=__PACKAGE__->_new((2**$XOR_BITS));
$OR_MASK=__PACKAGE__->_new((2**$OR_BITS));
*_alen=\&_len;}sub _zero{my$class=shift;
return bless[0],$class;}sub _one{my$class=shift;
return bless[1],$class;}sub _two{my$class=shift;
return bless[2],$class;}sub _ten{my$class=shift;
bless[10],$class;}sub _1ex{my$class=shift;
my$rem=$_[0]%$BASE_LEN;
my$parts=$_[0]/$BASE_LEN;
bless[(0)x$parts,'1'.('0' x$rem)],$class;}sub _copy{my$class=shift;
return bless[@{$_[0]}],$class;}sub import{}sub _str{my$ary=$_[1];
my$idx=$#$ary;
if($idx<0){croak("$_[1] has no elements");}my$ret=int($ary->[$idx]);
if($idx>0){my$z='0' x($BASE_LEN-1);
while(--$idx>=0){$ret.=substr($z.$ary->[$idx],-$BASE_LEN);}}$ret;}sub _num{my$x=$_[1];
return$x->[0]if@$x==1;
my$num=0;
for(my$i=$#$x;$i>=0;--$i){$num*=$BASE;
$num+=$x->[$i];}return$num;}sub _add{my($c,$x,$y)=@_;
return$x if@$y==1&&$y->[0]==0;
if(@$x==1&&$x->[0]==0){@$x=@$y;
return$x;}my$i;
my$car=0;
my$j=0;
for$i(@$y){$x->[$j]-=$BASE if$car=(($x->[$j]+=$i+$car)>=$BASE)?1:0;
$j++;}while($car!=0){$x->[$j]-=$BASE if$car=(($x->[$j]+=$car)>=$BASE)?1:0;
$j++;}$x;}sub _inc{my($c,$x)=@_;
for my $i(@$x){return$x if($i+=1)<$BASE;
$i=0;}push@$x,1 if$x->[-1]==0;
$x;}sub _dec{my($c,$x)=@_;
my$MAX=$BASE-1;
for my $i(@$x){last if($i-=1)>=0;
$i=$MAX;}pop@$x if$x->[-1]==0&&@$x>1;
$x;}sub _sub{my($c,$sx,$sy,$s)=@_;
my$car=0;
my$i;
my$j=0;
if(!$s){for$i(@$sx){last unless defined$sy->[$j]||$car;
$i+=$BASE if$car=(($i-=($sy->[$j]||0)+$car)<0);
$j++;}return __strip_zeros($sx);}for$i(@$sx){$sy->[$j]+=$BASE if$car=($sy->[$j]=$i-($sy->[$j]||0)-$car)<0;
$j++;}__strip_zeros($sy);}sub _mul_use_mul{my($c,$xv,$yv)=@_;
if(@$yv==1){if(@$xv==1){if(($xv->[0]*=$yv->[0])>=$BASE){$xv->[0]=$xv->[0]-($xv->[1]=int($xv->[0]*$RBASE))*$BASE;}return$xv;}if($yv->[0]==0){@$xv=(0);
return$xv;}my$y=$yv->[0];
my$car=0;
foreach my $i(@$xv){$i=$i*$y+$car;
$car=int($i*$RBASE);
$i-=$car*$BASE;}push@$xv,$car if$car!=0;
return$xv;}return$xv if@$xv==1&&$xv->[0]==0;
$yv=[@$xv]if$xv==$yv;
my@prod=();
my($prod,$car,$cty,$xi,$yi);
for$xi(@$xv){$car=0;
$cty=0;
$xi=(shift@prod||0),next if$xi==0;
for$yi(@$yv){$prod=$xi*$yi+($prod[$cty]||0)+$car;
$prod[$cty++]=$prod-($car=int($prod*$RBASE))*$BASE;}$prod[$cty]+=$car if$car;
$xi=shift@prod||0;}push@$xv,@prod;
$xv;}sub _mul_use_div_64{my($c,$xv,$yv)=@_;
use integer;
if(@$yv==1){if(@$xv==1){if(($xv->[0]*=$yv->[0])>=$BASE){$xv->[0]=$xv->[0]-($xv->[1]=$xv->[0]/$BASE)*$BASE;}return$xv;}if($yv->[0]==0){@$xv=(0);
return$xv;}my$y=$yv->[0];
my$car=0;
foreach my $i(@$xv){$i=$i*$y+$car;
$i-=($car=$i/$BASE)*$BASE;}push@$xv,$car if$car!=0;
return$xv;}return$xv if(((@$xv==1)&&($xv->[0]==0)));
$yv=$c->_copy($xv)if$xv==$yv;
my@prod=();
my($prod,$car,$cty,$xi,$yi);
for$xi(@$xv){$car=0;
$cty=0;
$xi=(shift@prod||0),next if$xi==0;
for$yi(@$yv){$prod=$xi*$yi+($prod[$cty]||0)+$car;
$prod[$cty++]=$prod-($car=$prod/$BASE)*$BASE;}$prod[$cty]+=$car if$car;
$xi=shift@prod||0;}push@$xv,@prod;
$xv;}sub _mul_use_div{my($c,$xv,$yv)=@_;
if(@$yv==1){if(@$xv==1){if(($xv->[0]*=$yv->[0])>=$BASE){$xv->[0]=$xv->[0]-($xv->[1]=int($xv->[0]/$BASE))*$BASE;}return$xv;}if($yv->[0]==0){@$xv=(0);
return$xv;}my$y=$yv->[0];
my$car=0;
foreach my $i(@$xv){$i=$i*$y+$car;
$car=int($i/$BASE);
$i-=$car*$BASE;}push@$xv,$car if$car!=0;
return$xv;}return$xv if(((@$xv==1)&&($xv->[0]==0)));
$yv=$c->_copy($xv)if$xv==$yv;
my@prod=();
my($prod,$car,$cty,$xi,$yi);
for$xi(@$xv){$car=0;
$cty=0;
$xi=(shift@prod||0),next if$xi==0;
for$yi(@$yv){$prod=$xi*$yi+($prod[$cty]||0)+$car;
$prod[$cty++]=$prod-($car=int($prod/$BASE))*$BASE;}$prod[$cty]+=$car if$car;
$xi=shift@prod||0;}push@$xv,@prod;
$xv;}sub _div_use_mul{my($c,$x,$yorg)=@_;
if(@$x==1&&@$yorg==1){if(wantarray){my$rem=[$x->[0]%$yorg->[0]];
bless$rem,$c;
$x->[0]=int($x->[0]/$yorg->[0]);
return($x,$rem);}else{$x->[0]=int($x->[0]/$yorg->[0]);
return$x;}}if(@$yorg==1){my$rem;
$rem=$c->_mod($c->_copy($x),$yorg)if wantarray;
my$j=@$x;
my$r=0;
my$y=$yorg->[0];
my$b;
while($j-- >0){$b=$r*$BASE+$x->[$j];
$x->[$j]=int($b/$y);
$r=$b%$y;}pop@$x if@$x>1&&$x->[-1]==0;
return($x,$rem)if wantarray;
return$x;}if(@$yorg>@$x){my$rem;
$rem=$c->_copy($x)if wantarray;
@$x=0;
return($x,$rem)if wantarray;
return$x;}if(@$yorg==@$x){if(length(int($yorg->[-1]))>length(int($x->[-1]))){my$rem=$c->_copy($x)if wantarray;
@$x=0;
return($x,$rem)if wantarray;
return$x;}if(length(int($yorg->[-1]))==length(int($x->[-1]))){my$a=0;
my$j=@$x-1;
while($j>=0){last if($a=$x->[$j]-$yorg->[$j]);
$j--;}if($a<=0){my$rem=$a==0?$c->_zero():$c->_copy($x);
@$x=0;
$x->[0]=1 if$a==0;
return($x,$rem)if wantarray;
return$x;}}}my$y=$c->_copy($yorg);
my($car,$bar,$prd,$dd,$xi,$yi,@q,$v2,$v1,$tmp,$q,$u2,$u1,$u0);
$car=$bar=$prd=0;
if(($dd=int($BASE/($y->[-1]+1)))!=1){for$xi(@$x){$xi=$xi*$dd+$car;
$xi-=($car=int($xi*$RBASE))*$BASE;}push(@$x,$car);
$car=0;
for$yi(@$y){$yi=$yi*$dd+$car;
$yi-=($car=int($yi*$RBASE))*$BASE;}}else{push(@$x,0);}@q=();
($v2,$v1)=@$y[-2,-1];
$v2=0 unless$v2;
while($#$x>$#$y){($u2,$u1,$u0)=@$x[-3..-1];
$u2=0 unless$u2;
$q=(($u0==$v1)?$MAX_VAL:int(($u0*$BASE+$u1)/$v1));
--$q while($v2*$q>($u0*$BASE+$u1-$q*$v1)*$BASE+$u2);
if($q){($car,$bar)=(0,0);
for($yi=0,$xi=$#$x-$#$y-1;$yi<=$#$y;++$yi, ++$xi){$prd=$q*$y->[$yi]+$car;
$prd-=($car=int($prd*$RBASE))*$BASE;
$x->[$xi]+=$BASE if($bar=(($x->[$xi]-=$prd+$bar)<0));}if($x->[-1]<$car+$bar){$car=0;
--$q;
for($yi=0,$xi=$#$x-$#$y-1;$yi<=$#$y;++$yi, ++$xi){$x->[$xi]-=$BASE if($car=(($x->[$xi]+=$y->[$yi]+$car)>=$BASE));}}}pop(@$x);
unshift(@q,$q);}if(wantarray){my$d=bless[],$c;
if($dd!=1){$car=0;
for$xi(reverse@$x){$prd=$car*$BASE+$xi;
$car=$prd-($tmp=int($prd/$dd))*$dd;
unshift(@$d,$tmp);}}else{@$d=@$x;}@$x=@q;
__strip_zeros($x);
__strip_zeros($d);
return($x,$d);}@$x=@q;
__strip_zeros($x);
$x;}sub _div_use_div_64{my($c,$x,$yorg)=@_;
use integer;
if(@$x==1&&@$yorg==1){if(wantarray){my$rem=[$x->[0]%$yorg->[0]];
bless$rem,$c;
$x->[0]=int($x->[0]/$yorg->[0]);
return($x,$rem);}else{$x->[0]=int($x->[0]/$yorg->[0]);
return$x;}}if(@$yorg==1){my$rem;
$rem=$c->_mod($c->_copy($x),$yorg)if wantarray;
my$j=@$x;
my$r=0;
my$y=$yorg->[0];
my$b;
while($j-- >0){$b=$r*$BASE+$x->[$j];
$x->[$j]=int($b/$y);
$r=$b%$y;}pop@$x if@$x>1&&$x->[-1]==0;
return($x,$rem)if wantarray;
return$x;}if(@$yorg>@$x){my$rem;
$rem=$c->_copy($x)if wantarray;
@$x=0;
return($x,$rem)if wantarray;
return$x;}if(@$yorg==@$x){my$rem;
if(length(int($yorg->[-1]))>length(int($x->[-1]))){$rem=$c->_copy($x)if wantarray;
@$x=0;
return($x,$rem)if wantarray;
return$x;}if(length(int($yorg->[-1]))==length(int($x->[-1]))){my$a=0;
my$j=@$x-1;
while($j>=0){last if($a=$x->[$j]-$yorg->[$j]);
$j--;}if($a<=0){$rem=$c->_zero();
$rem=$c->_copy($x)if$a!=0;
@$x=0;
$x->[0]=1 if$a==0;
return($x,$rem)if wantarray;
return$x;}}}my$y=$c->_copy($yorg);
my($car,$bar,$prd,$dd,$xi,$yi,@q,$v2,$v1,$tmp,$q,$u2,$u1,$u0);
$car=$bar=$prd=0;
if(($dd=int($BASE/($y->[-1]+1)))!=1){for$xi(@$x){$xi=$xi*$dd+$car;
$xi-=($car=int($xi/$BASE))*$BASE;}push(@$x,$car);
$car=0;
for$yi(@$y){$yi=$yi*$dd+$car;
$yi-=($car=int($yi/$BASE))*$BASE;}}else{push(@$x,0);}@q=();
($v2,$v1)=@$y[-2,-1];
$v2=0 unless$v2;
while($#$x>$#$y){($u2,$u1,$u0)=@$x[-3..-1];
$u2=0 unless$u2;
$q=(($u0==$v1)?$MAX_VAL:int(($u0*$BASE+$u1)/$v1));
--$q while($v2*$q>($u0*$BASE+$u1-$q*$v1)*$BASE+$u2);
if($q){($car,$bar)=(0,0);
for($yi=0,$xi=$#$x-$#$y-1;$yi<=$#$y;++$yi, ++$xi){$prd=$q*$y->[$yi]+$car;
$prd-=($car=int($prd/$BASE))*$BASE;
$x->[$xi]+=$BASE if($bar=(($x->[$xi]-=$prd+$bar)<0));}if($x->[-1]<$car+$bar){$car=0;
--$q;
for($yi=0,$xi=$#$x-$#$y-1;$yi<=$#$y;++$yi, ++$xi){$x->[$xi]-=$BASE if($car=(($x->[$xi]+=$y->[$yi]+$car)>=$BASE));}}}pop(@$x);
unshift(@q,$q);}if(wantarray){my$d=bless[],$c;
if($dd!=1){$car=0;
for$xi(reverse@$x){$prd=$car*$BASE+$xi;
$car=$prd-($tmp=int($prd/$dd))*$dd;
unshift(@$d,$tmp);}}else{@$d=@$x;}@$x=@q;
__strip_zeros($x);
__strip_zeros($d);
return($x,$d);}@$x=@q;
__strip_zeros($x);
$x;}sub _div_use_div{my($c,$x,$yorg)=@_;
if(@$x==1&&@$yorg==1){if(wantarray){my$rem=[$x->[0]%$yorg->[0]];
bless$rem,$c;
$x->[0]=int($x->[0]/$yorg->[0]);
return($x,$rem);}else{$x->[0]=int($x->[0]/$yorg->[0]);
return$x;}}if(@$yorg==1){my$rem;
$rem=$c->_mod($c->_copy($x),$yorg)if wantarray;
my$j=@$x;
my$r=0;
my$y=$yorg->[0];
my$b;
while($j-- >0){$b=$r*$BASE+$x->[$j];
$x->[$j]=int($b/$y);
$r=$b%$y;}pop@$x if@$x>1&&$x->[-1]==0;
return($x,$rem)if wantarray;
return$x;}if(@$yorg>@$x){my$rem;
$rem=$c->_copy($x)if wantarray;
@$x=0;
return($x,$rem)if wantarray;
return$x;}if(@$yorg==@$x){my$rem;
if(length(int($yorg->[-1]))>length(int($x->[-1]))){$rem=$c->_copy($x)if wantarray;
@$x=0;
return($x,$rem)if wantarray;
return$x;}if(length(int($yorg->[-1]))==length(int($x->[-1]))){my$a=0;
my$j=@$x-1;
while($j>=0){last if($a=$x->[$j]-$yorg->[$j]);
$j--;}if($a<=0){$rem=$c->_zero();
$rem=$c->_copy($x)if$a!=0;
@$x=0;
$x->[0]=0;
$x->[0]=1 if$a==0;
return($x,$rem)if wantarray;
return$x;}}}my$y=$c->_copy($yorg);
my($car,$bar,$prd,$dd,$xi,$yi,@q,$v2,$v1,@d,$tmp,$q,$u2,$u1,$u0);
$car=$bar=$prd=0;
if(($dd=int($BASE/($y->[-1]+1)))!=1){for$xi(@$x){$xi=$xi*$dd+$car;
$xi-=($car=int($xi/$BASE))*$BASE;}push(@$x,$car);
$car=0;
for$yi(@$y){$yi=$yi*$dd+$car;
$yi-=($car=int($yi/$BASE))*$BASE;}}else{push(@$x,0);}@q=();
($v2,$v1)=@$y[-2,-1];
$v2=0 unless$v2;
while($#$x>$#$y){($u2,$u1,$u0)=@$x[-3..-1];
$u2=0 unless$u2;
$q=(($u0==$v1)?$MAX_VAL:int(($u0*$BASE+$u1)/$v1));
--$q while($v2*$q>($u0*$BASE+$u1-$q*$v1)*$BASE+$u2);
if($q){($car,$bar)=(0,0);
for($yi=0,$xi=$#$x-$#$y-1;$yi<=$#$y;++$yi, ++$xi){$prd=$q*$y->[$yi]+$car;
$prd-=($car=int($prd/$BASE))*$BASE;
$x->[$xi]+=$BASE if($bar=(($x->[$xi]-=$prd+$bar)<0));}if($x->[-1]<$car+$bar){$car=0;
--$q;
for($yi=0,$xi=$#$x-$#$y-1;$yi<=$#$y;++$yi, ++$xi){$x->[$xi]-=$BASE if($car=(($x->[$xi]+=$y->[$yi]+$car)>=$BASE));}}}pop(@$x);
unshift(@q,$q);}if(wantarray){my$d=bless[],$c;
if($dd!=1){$car=0;
for$xi(reverse@$x){$prd=$car*$BASE+$xi;
$car=$prd-($tmp=int($prd/$dd))*$dd;
unshift(@$d,$tmp);}}else{@$d=@$x;}@$x=@q;
__strip_zeros($x);
__strip_zeros($d);
return($x,$d);}@$x=@q;
__strip_zeros($x);
$x;}sub _acmp{my($c,$cx,$cy)=@_;
return(($cx->[0]<=>$cy->[0])<=>0)if@$cx==1&&@$cy==1;
my$lxy=(@$cx-@$cy)||(length(int($cx->[-1]))-length(int($cy->[-1])));
return-1 if$lxy<0;
return  1 if$lxy>0;
my$a;
my$j=@$cx;
while(--$j>=0){last if$a=$cx->[$j]-$cy->[$j];}$a<=>0;}sub _len{my$cx=$_[1];
(@$cx-1)*$BASE_LEN+length(int($cx->[-1]));}sub _digit{my($c,$x,$n)=@_;
my$len=_len('',$x);
$n+=$len if$n<0;
return"0" if$n<0||$n>=$len;
my$elem=int($n/$BASE_LEN);
my$digit=$n%$BASE_LEN;
substr("0" x$BASE_LEN."$x->[$elem]",-1-$digit,1);}sub _zeros{my$x=$_[1];
return 0 if@$x==1&&$x->[0]==0;
my$zeros=0;
foreach my $elem(@$x){if($elem!=0){$elem=~/[^0](0*)\z/;
$zeros+=length($1);
last;}$zeros+=$BASE_LEN;}$zeros;}sub _is_zero{@{$_[1]}==1&&$_[1]->[0]==0?1:0;}sub _is_even{$_[1]->[0]&1?0:1;}sub _is_odd{$_[1]->[0]&1?1:0;}sub _is_one{@{$_[1]}==1&&$_[1]->[0]==1?1:0;}sub _is_two{@{$_[1]}==1&&$_[1]->[0]==2?1:0;}sub _is_ten{@{$_[1]}==1&&$_[1]->[0]==10?1:0;}sub __strip_zeros{my$x=shift;
push@$x,0 if@$x==0;
return$x if@$x==1;
my$i=$#$x;
while($i>0){last if$x->[$i]!=0;
$i--;}$i++;
splice(@$x,$i)if$i<@$x;
$x;}sub _check{my($class,$x)=@_;
my$msg=$class->SUPER::_check($x);
return$msg if$msg;
my$n;
eval{$n=@$x};
return"Not an array reference" unless$@eq '';
return"Reference to an empty array" unless$n>0;
for(my$i=0;$i<=$#$x;++$i){my$e=$x->[$i];
return"Element at index $i is undefined" unless defined$e;
return"Element at index $i is a '".ref($e)."', which is not a scalar" unless ref($e)eq"";
return"Element at index $i is '$e', which does not look like an"." normal integer" unless$e=~/^\d+\z/;
return"Element at index $i is '$e', which is not smaller than"." the base '$BASE'" if$e>=$BASE;
return"Element at index $i (last element) is zero" if$#$x>0&&$i==$#$x&&$e==0;}return 0;}sub _mod{my($c,$x,$yo)=@_;
if(@$yo>1){my($xo,$rem)=$c->_div($x,$yo);
@$x=@$rem;
return$x;}my$y=$yo->[0];
if(@$x==1){$x->[0]%=$y;
return$x;}my$b=$BASE%$y;
if($b==0){$x->[0]%=$y;}elsif($b==1){my$r=0;
foreach(@$x){$r=($r+$_)%$y;}$r=0 if$r==$y;
$x->[0]=$r;}else{my$r=0;
my$bm=1;
foreach(@$x){$r=($_*$bm+$r)%$y;
$bm=($bm*$b)%$y;}$r=0 if$r==$y;
$x->[0]=$r;}@$x=$x->[0];
return$x;}sub _rsft{my($c,$x,$y,$n)=@_;
if($n!=10){$n=$c->_new($n);
return scalar$c->_div($x,$c->_pow($n,$y));}my$dst=0;
my$src=$c->_num($y);
my$xlen=(@$x-1)*$BASE_LEN+length(int($x->[-1]));
if($src>=$xlen or($src==$xlen and!defined$x->[1])){splice(@$x,1);
$x->[0]=0;
return$x;}my$rem=$src%$BASE_LEN;
$src=int($src/$BASE_LEN);
if($rem==0){splice(@$x,0,$src);}else{my$len=@$x-$src;
my$vd;
my$z='0' x$BASE_LEN;
$x->[@$x]=0;
while($dst<$len){$vd=$z.$x->[$src];
$vd=substr($vd,-$BASE_LEN,$BASE_LEN-$rem);
$src++;
$vd=substr($z.$x->[$src],-$rem,$rem).$vd;
$vd=substr($vd,-$BASE_LEN,$BASE_LEN)if length($vd)>$BASE_LEN;
$x->[$dst]=int($vd);
$dst++;}splice(@$x,$dst)if$dst>0;
pop@$x if$x->[-1]==0&&@$x>1;}$x;}sub _lsft{my($c,$x,$n,$b)=@_;
return$x if$c->_is_zero($x);
my$log10=sprintf"%.0f",log($b)/log(10);
if($b==10**$log10){$b=10;
$n=$c->_mul($n,$c->_new($log10));
my$src=@$x;
my$len=$c->_num($n);
my$rem=$len%$BASE_LEN;
my$dst=$src+int($len/$BASE_LEN);
my$vd;
$x->[$src]=0;
my$z='0' x$BASE_LEN;
while($src>=0){$vd=$x->[$src];
$vd=$z.$vd;
$vd=substr($vd,-$BASE_LEN+$rem,$BASE_LEN-$rem);
$vd.=$src>0?substr($z.$x->[$src-1],-$BASE_LEN,$rem):'0' x$rem;
$vd=substr($vd,-$BASE_LEN,$BASE_LEN)if length($vd)>$BASE_LEN;
$x->[$dst]=int($vd);
$dst--;
$src--;}while($dst>=0){$x->[$dst--]=0;}splice@$x,-1 if$x->[-1]==0;
return$x;}else{$b=$c->_new($b);
return$c->_mul($x,$c->_pow($b,$n));}}sub _pow{my($c,$cx,$cy)=@_;
if(@$cy==1&&$cy->[0]==0){splice(@$cx,1);
$cx->[0]=1;
return$cx;}if((@$cx==1&&$cx->[0]==1)||(@$cy==1&&$cy->[0]==1)){return$cx;}if(@$cx==1&&$cx->[0]==0){splice(@$cx,1);
$cx->[0]=0;
return$cx;}my$pow2=$c->_one();
my$y_bin=$c->_as_bin($cy);
$y_bin=~s/^0b//;
my$len=length($y_bin);
while(--$len>0){$c->_mul($pow2,$cx)if substr($y_bin,$len,1)eq '1';
$c->_mul($cx,$cx);}$c->_mul($cx,$pow2);
$cx;}sub _nok{my($c,$n,$k)=@_;
{my$twok=$c->_mul($c->_two(),$c->_copy($k));
if($c->_acmp($twok,$n)>0){$k=$c->_sub($c->_copy($n),$k);}}if($c->_is_zero($k)){@$n=1;}else{my$n_orig=$c->_copy($n);
$c->_sub($n,$k);
$c->_inc($n);
my$f=$c->_copy($n);
$c->_inc($f);
my$d=$c->_two();
while($c->_acmp($f,$n_orig)<=0){$c->_mul($n,$f);
$c->_div($n,$d);
$c->_inc($f);
$c->_inc($d);}}return$n;}my@factorials=(1,1,2,2*3,2*3*4,2*3*4*5,2*3*4*5*6,2*3*4*5*6*7,);
sub _fac{my($c,$cx)=@_;
if((@$cx==1)&&($cx->[0]<=7)){$cx->[0]=$factorials[$cx->[0]];
return$cx;}if((@$cx==1)&&($cx->[0]>=12&&$cx->[0]<7000)){my$zero_elements=0;
my$k=$c->_num($cx);
my$even=1;
if(($k&1)==0){$even=$k;
$k--;}$k=($k+1)/2;
my$k2=$k*$k;
my$odd=1;
my$sum=1;
my$i=$k-1;
my$new_x=$c->_new($k*$even);
@$cx=@$new_x;
if($cx->[0]==0){$zero_elements++;
shift@$cx;}my$BASE2=int(sqrt($BASE))-1;
my$j=1;
while($j<=$i){my$m=($k2-$sum);
$odd+=2;
$sum+=$odd;
$j++;
while($j<=$i&&($m<$BASE2)&&(($k2-$sum)<$BASE2)){$m*=($k2-$sum);
$odd+=2;
$sum+=$odd;
$j++;}if($m<$BASE){$c->_mul($cx,[$m]);}else{$c->_mul($cx,$c->_new($m));}if($cx->[0]==0){$zero_elements++;
shift@$cx;}}unshift@$cx,(0)x$zero_elements;
return$cx;}my$steps=100;
$steps=$cx->[0]if@$cx==1;
my$r=2;
my$cf=3;
my$step=2;
my$last=$r;
while($r*$cf<$BASE&&$step<$steps){$last=$r;
$r*=$cf++;
$step++;}if((@$cx==1)&&$step==$cx->[0]){$cx->[0]=$r;
return$cx;}my$n;
if(@$cx==1){$n=$cx->[0];}else{$n=$c->_copy($cx);}$cx->[0]=$last;
splice(@$cx,1);
my$zero_elements=0;
if(ref$n eq 'ARRAY'){my$base_2=int(sqrt($BASE))-1;
while($step<$base_2){if($cx->[0]==0){$zero_elements++;
shift@$cx;}my$b=$step*($step+1);
$step+=2;
$c->_mul($cx,[$b]);}$step=[$step];
while($c->_acmp($step,$n)<=0){if($cx->[0]==0){$zero_elements++;
shift@$cx;}$c->_mul($cx,$step);
$c->_inc($step);}}else{my$base_4=int(sqrt(sqrt($BASE)))-2;
my$n4=$n-4;
while($step<$n4&&$step<$base_4){if($cx->[0]==0){$zero_elements++;
shift@$cx;}my$b=$step*($step+1);
$step+=2;
$b*=$step*($step+1);
$step+=2;
$c->_mul($cx,[$b]);}my$base_2=int(sqrt($BASE))-1;
my$n2=$n-2;
while($step<$n2&&$step<$base_2){if($cx->[0]==0){$zero_elements++;
shift@$cx;}my$b=$step*($step+1);
$step+=2;
$c->_mul($cx,[$b]);}while($step<=$n){$c->_mul($cx,[$step]);
$step++;
if($cx->[0]==0){$zero_elements++;
shift@$cx;}}}unshift@$cx,(0)x$zero_elements;
$cx;}sub _log_int{my($c,$x,$base)=@_;
return if@$x==1&&$x->[0]==0;
return if@$base==1&&$base->[0]<2;
if(@$x==1&&$x->[0]==1){@$x=0;
return$x,1;}my$cmp=$c->_acmp($x,$base);
if($cmp==0){@$x=1;
return$x,1;}if($cmp<0){@$x=0;
return$x,0;}my$x_org=$c->_copy($x);
my$len=$c->_len($x_org);
my$log=log($base->[-1])/log(10);
$log+=(@$base-1)*$BASE_LEN;
my$res=int($len/$log);
@$x=$res;
my$trial=$c->_pow($c->_copy($base),$x);
my$acmp=$c->_acmp($trial,$x_org);
return$x,1 if$acmp==0;
while($acmp<0){$c->_mul($trial,$base);
$c->_inc($x);
$acmp=$c->_acmp($trial,$x_org);}while($acmp>0){$c->_div($trial,$base);
$c->_dec($x);
$acmp=$c->_acmp($trial,$x_org);}return$x,1 if$acmp==0;
return$x,0;}use constant DEBUG=>0;
my$steps=0;
sub steps{$steps}sub _sqrt{my($c,$x)=@_;
if(@$x==1){$x->[0]=int(sqrt($x->[0]));
return$x;}my$y=$c->_copy($x);
my$l=int(($c->_len($x)-1)/2);
my$lastelem=$x->[-1];
my$elems=@$x-1;
if((length($lastelem)<=3)&&($elems>1)){my$len=length($lastelem)&1;
print"$lastelem => " if DEBUG;
$lastelem.=substr($x->[-2].'0' x$BASE_LEN,0,$BASE_LEN);
$lastelem=$lastelem/10 if(length($lastelem)&1)!=$len;
print"$lastelem\n" if DEBUG;}my$r=$l%$BASE_LEN;
$l=int($l/$BASE_LEN);
print"l =  $l " if DEBUG;
splice@$x,$l;
print"$lastelem (elems $elems) => " if DEBUG;
$lastelem=$lastelem/10 if($elems&1==1);
my$g=sqrt($lastelem);
$g=~s/\.//;
$r-=1 if$elems&1==0;
$x->[$l--]=int(substr($g.'0' x$r,0,$r+1));
print"now ",$x->[-1]if DEBUG;
print" would have been ",int('1'.'0' x$r),"\n" if DEBUG;
$x->[$l--]=0 while($l>=0);
print"start x= ",$c->_str($x),"\n" if DEBUG;
my$two=$c->_two();
my$last=$c->_zero();
my$lastlast=$c->_zero();
$steps=0 if DEBUG;
while($c->_acmp($last,$x)!=0&&$c->_acmp($lastlast,$x)!=0){$steps++ if DEBUG;
$lastlast=$c->_copy($last);
$last=$c->_copy($x);
$c->_add($x,$c->_div($c->_copy($y),$x));
$c->_div($x,$two);
print" x= ",$c->_str($x),"\n" if DEBUG;}print"\nsteps in sqrt: $steps, " if DEBUG;
$c->_dec($x)if$c->_acmp($y,$c->_mul($c->_copy($x),$x))<0;
print" final ",$x->[-1],"\n" if DEBUG;
$x;}sub _root{my($c,$x,$n)=@_;
if(@$x==1&&@$n==1){my$y=int($x->[0]**(1/$n->[0]));
my$yp1=$y+1;
$y=$yp1 if$yp1**$n->[0]==$x->[0];
$x->[0]=$y;
return$x;}if((@$x>1||$x->[0]>0)&&$c->_acmp($x,$n)<=0){my$one=$x->_one();
@$x=@$one;
return$x;}my$b=$c->_as_bin($n);
if($b=~/0b1(0+)$/){my$count=length($1);
my$cnt=$count;
unshift@$x,0;
while($cnt-- >0){unshift@$x,0;
$c->_sqrt($x);}shift@$x;
return$x;}my$DEBUG=0;
my$x_str=$c->_str($x);
my$xm=".".$x_str;
my$xe=length($x_str);
my$log10x=log($xm)/log(10)+$xe;
my$log10y=$log10x/$c->_num($n);
my$ye=int$log10y;
my$ym=10**($log10y-$ye);
if($DEBUG){print"\n";
print"xm     = $xm\n";
print"xe     = $xe\n";
print"log10x = $log10x\n";
print"log10y = $log10y\n";
print"ym     = $ym\n";
print"ye     = $ye\n";
print"\n";}my$d=$ye<15?$ye:15;
$ym*=10**$d;
$ye-=$d;
my$y_str=sprintf('%.0f',$ym)."0" x$ye;
my$y=$c->_new($y_str);
if($DEBUG){print"ym     = $ym\n";
print"ye     = $ye\n";
print"\n";
print"y_str  = $y_str (initial guess)\n";
print"\n";}my$trial=$c->_pow($c->_copy($y),$n);
my$acmp=$c->_acmp($trial,$x);
if($acmp==0){@$x=@$y;
return$x;}my$lower;
my$upper;
my$delta=$c->_new("1".("0" x$ye));
my$two=$c->_two();
if($acmp<0){$lower=$y;
while($acmp<0){$upper=$c->_add($c->_copy($lower),$delta);
if($DEBUG){print"lower  = $lower\n";
print"upper  = $upper\n";
print"delta  = $delta\n";
print"\n";}$acmp=$c->_acmp($c->_pow($c->_copy($upper),$n),$x);
if($acmp==0){@$x=@$upper;
return$x;}$delta=$c->_mul($delta,$two);}}elsif($acmp>0){$upper=$y;
while($acmp>0){if($c->_acmp($upper,$delta)<=0){$lower=$c->_zero();
last;}$lower=$c->_sub($c->_copy($upper),$delta);
if($DEBUG){print"lower  = $lower\n";
print"upper  = $upper\n";
print"delta  = $delta\n";
print"\n";}$acmp=$c->_acmp($c->_pow($c->_copy($lower),$n),$x);
if($acmp==0){@$x=@$lower;
return$x;}$delta=$c->_mul($delta,$two);}}my$one=$c->_one();
{$delta=$c->_sub($c->_copy($upper),$lower);
if($c->_acmp($delta,$one)<=0){@$x=@$lower;
return$x;}if($DEBUG){print"lower  = $lower\n";
print"upper  = $upper\n";
print"delta   = $delta\n";
print"\n";}$delta=$c->_div($delta,$two);
my$middle=$c->_add($c->_copy($lower),$delta);
$acmp=$c->_acmp($c->_pow($c->_copy($middle),$n),$x);
if($acmp<0){$lower=$middle;}elsif($acmp>0){$upper=$middle;}else{@$x=@$middle;
return$x;}redo;}$x;}sub _and{my($c,$x,$y)=@_;
return$x if$c->_acmp($x,$y)==0;
my$m=$c->_one();
my($xr,$yr);
my$mask=$AND_MASK;
my$x1=$c->_copy($x);
my$y1=$c->_copy($y);
my$z=$c->_zero();
use integer;
until($c->_is_zero($x1)||$c->_is_zero($y1)){($x1,$xr)=$c->_div($x1,$mask);
($y1,$yr)=$c->_div($y1,$mask);
$c->_add($z,$c->_mul([0+$xr->[0]&0+$yr->[0]],$m));
$c->_mul($m,$mask);}@$x=@$z;
return$x;}sub _xor{my($c,$x,$y)=@_;
return$c->_zero()if$c->_acmp($x,$y)==0;
my$m=$c->_one();
my($xr,$yr);
my$mask=$XOR_MASK;
my$x1=$c->_copy($x);
my$y1=$c->_copy($y);
my$z=$c->_zero();
use integer;
until($c->_is_zero($x1)||$c->_is_zero($y1)){($x1,$xr)=$c->_div($x1,$mask);
($y1,$yr)=$c->_div($y1,$mask);
$c->_add($z,$c->_mul([0+$xr->[0]^0+$yr->[0]],$m));
$c->_mul($m,$mask);}$c->_add($z,$c->_mul($x1,$m))if!$c->_is_zero($x1);
$c->_add($z,$c->_mul($y1,$m))if!$c->_is_zero($y1);
@$x=@$z;
return$x;}sub _or{my($c,$x,$y)=@_;
return$x if$c->_acmp($x,$y)==0;
my$m=$c->_one();
my($xr,$yr);
my$mask=$OR_MASK;
my$x1=$c->_copy($x);
my$y1=$c->_copy($y);
my$z=$c->_zero();
use integer;
until($c->_is_zero($x1)||$c->_is_zero($y1)){($x1,$xr)=$c->_div($x1,$mask);
($y1,$yr)=$c->_div($y1,$mask);
$c->_add($z,$c->_mul([0+$xr->[0]|0+$yr->[0]],$m));
$c->_mul($m,$mask);}$c->_add($z,$c->_mul($x1,$m))if!$c->_is_zero($x1);
$c->_add($z,$c->_mul($y1,$m))if!$c->_is_zero($y1);
@$x=@$z;
return$x;}sub _as_hex{my($c,$x)=@_;
return sprintf("0x%x",$x->[0])if@$x==1;
my$x1=$c->_copy($x);
my$es='';
my($xr,$h,$x10000);
if($]>=5.006){$x10000=[0x10000];
$h='h4';}else{$x10000=[0x1000];
$h='h3';}while(@$x1!=1||$x1->[0]!=0){($x1,$xr)=$c->_div($x1,$x10000);
$es.=unpack($h,pack('V',$xr->[0]));}$es=reverse$es;
$es=~s/^[0]+//;
'0x'.$es;}sub _as_bin{my($c,$x)=@_;
if($]<=5.005&&@$x==1&&$x->[0]==0){my$t='0b0';
return$t;}if(@$x==1&&$]>=5.006){my$t=sprintf("0b%b",$x->[0]);
return$t;}my$x1=$c->_copy($x);
my$es='';
my($xr,$b,$x10000);
if($]>=5.006){$x10000=[0x10000];
$b='b16';}else{$x10000=[0x1000];
$b='b12';}while(!(@$x1==1&&$x1->[0]==0)){($x1,$xr)=$c->_div($x1,$x10000);
$es.=unpack($b,pack('v',$xr->[0]));}$es=reverse$es;
$es=~s/^[0]+//;
'0b'.$es;}sub _as_oct{my($c,$x)=@_;
return sprintf("0%o",$x->[0])if@$x==1;
my$x1=$c->_copy($x);
my$es='';
my$xr;
my$x1000=[0100000];
while(@$x1!=1||$x1->[0]!=0){($x1,$xr)=$c->_div($x1,$x1000);
$es.=reverse sprintf("%05o",$xr->[0]);}$es=reverse$es;
$es=~s/^0+//;
'0'.$es;}sub _from_oct{my($c,$os)=@_;
my$m=[0100000];
my$d=5;
my$mul=$c->_one();
my$x=$c->_zero();
my$len=int((length($os)-1)/$d);
my$val;
my$i=-$d;
while($len>=0){$val=substr($os,$i,$d);
$val=CORE::oct($val);
$i-=$d;
$len--;
my$adder=[$val];
$c->_add($x,$c->_mul($adder,$mul))if$val!=0;
$c->_mul($mul,$m)if$len>=0;}$x;}sub _from_hex{my($c,$hs)=@_;
my$m=$c->_new(0x10000000);
my$d=7;
my$mul=$c->_one();
my$x=$c->_zero();
my$len=int((length($hs)-2)/$d);
my$val;
my$i=-$d;
while($len>=0){$val=substr($hs,$i,$d);
$val=~s/^0x// if$len==0;
$val=CORE::hex($val);
$i-=$d;
$len--;
my$adder=[$val];
if(CORE::length($val)>$BASE_LEN){$adder=$c->_new($val);}$c->_add($x,$c->_mul($adder,$mul))if$val!=0;
$c->_mul($mul,$m)if$len>=0;}$x;}sub _from_bin{my($c,$bs)=@_;
my$hs=$bs;
$hs=~s/^[+-]?0b//;
my$l=length($hs);
$hs='0' x(8-($l%8)).$hs if($l%8)!=0;
my$h='0x'.unpack('H*',pack('B*',$hs));
$c->_from_hex($h);}sub _modinv{my($c,$x,$y)=@_;
if($c->_is_zero($y)){return undef,undef;}if($c->_is_one($y)){return$c->_zero(),'+';}my$u=$c->_zero();
my$v=$c->_one();
my$a=$c->_copy($y);
my$b=$c->_copy($x);
my$q;
my$sign=1;
{($a,$q,$b)=($b,$c->_div($a,$b));
last if$c->_is_zero($b);
my$t=$c->_add($c->_mul($c->_copy($v),$q),$u);
$u=$v;
$v=$t;
$sign=-$sign;
redo;}return(undef,undef)unless$c->_is_one($a);
($v,$sign==1?'+':'-');}sub _modpow{my($c,$num,$exp,$mod)=@_;
if($c->_is_one($mod)){@$num=0;
return$num;}if($c->_is_zero($num)){if($c->_is_zero($exp)){@$num=1;}else{@$num=0;}return$num;}my$acc=$c->_copy($num);
my$t=$c->_one();
my$expbin=$c->_as_bin($exp);
$expbin=~s/^0b//;
my$len=length($expbin);
while(--$len>=0){if(substr($expbin,$len,1)eq '1'){$t=$c->_mul($t,$acc);
$t=$c->_mod($t,$mod);}$acc=$c->_mul($acc,$acc);
$acc=$c->_mod($acc,$mod);}@$num=@$t;
$num;}sub _gcd{my($c,$x,$y)=@_;
if(@$x==1&&$x->[0]==0){if(@$y==1&&$y->[0]==0){@$x=0;}else{@$x=@$y;}return$x;}until(@$y==1&&$y->[0]==0){$c->_mod($x,$y);
my$tmp=$c->_copy($x);
@$x=@$y;
$y=$tmp;}return$x;}package Math::BigInt::Lib;
use 5.006001;
use strict;
use warnings;
our$VERSION='1.999813';
use Carp;
use overload '+'=>sub{my$class=ref$_[0];
my$x=$class->_copy($_[0]);
my$y=ref($_[1])?$_[1]:$class->_new($_[1]);
return$class->_add($x,$y);},'-'=>sub{my$class=ref$_[0];
my($x,$y);
if($_[2]){$y=$_[0];
$x=ref($_[1])?$_[1]:$class->_new($_[1]);}else{$x=$class->_copy($_[0]);
$y=ref($_[1])?$_[1]:$class->_new($_[1]);}return$class->_sub($x,$y);},'*'=>sub{my$class=ref$_[0];
my$x=$class->_copy($_[0]);
my$y=ref($_[1])?$_[1]:$class->_new($_[1]);
return$class->_mul($x,$y);},'/'=>sub{my$class=ref$_[0];
my($x,$y);
if($_[2]){$y=$_[0];
$x=ref($_[1])?$_[1]:$class->_new($_[1]);}else{$x=$class->_copy($_[0]);
$y=ref($_[1])?$_[1]:$class->_new($_[1]);}return$class->_div($x,$y);},'%'=>sub{my$class=ref$_[0];
my($x,$y);
if($_[2]){$y=$_[0];
$x=ref($_[1])?$_[1]:$class->_new($_[1]);}else{$x=$class->_copy($_[0]);
$y=ref($_[1])?$_[1]:$class->_new($_[1]);}return$class->_mod($x,$y);},'**'=>sub{my$class=ref$_[0];
my($x,$y);
if($_[2]){$y=$_[0];
$x=ref($_[1])?$_[1]:$class->_new($_[1]);}else{$x=$class->_copy($_[0]);
$y=ref($_[1])?$_[1]:$class->_new($_[1]);}return$class->_pow($x,$y);},'<<'=>sub{my$class=ref$_[0];
my($x,$y);
if($_[2]){$y=$class->_num($_[0]);
$x=ref($_[1])?$_[1]:$class->_new($_[1]);}else{$x=$_[0];
$y=ref($_[1])?$class->_num($_[1]):$_[1];}return$class->_blsft($x,$y);},'>>'=>sub{my$class=ref$_[0];
my($x,$y);
if($_[2]){$y=$_[0];
$x=ref($_[1])?$_[1]:$class->_new($_[1]);}else{$x=$class->_copy($_[0]);
$y=ref($_[1])?$_[1]:$class->_new($_[1]);}return$class->_brsft($x,$y);},'<'=>sub{my$class=ref$_[0];
my($x,$y);
if($_[2]){$y=$_[0];
$x=ref($_[1])?$_[1]:$class->_new($_[1]);}else{$x=$class->_copy($_[0]);
$y=ref($_[1])?$_[1]:$class->_new($_[1]);}return$class->_acmp($x,$y)<0;},'<='=>sub{my$class=ref$_[0];
my($x,$y);
if($_[2]){$y=$_[0];
$x=ref($_[1])?$_[1]:$class->_new($_[1]);}else{$x=$class->_copy($_[0]);
$y=ref($_[1])?$_[1]:$class->_new($_[1]);}return$class->_acmp($x,$y)<=0;},'>'=>sub{my$class=ref$_[0];
my($x,$y);
if($_[2]){$y=$_[0];
$x=ref($_[1])?$_[1]:$class->_new($_[1]);}else{$x=$class->_copy($_[0]);
$y=ref($_[1])?$_[1]:$class->_new($_[1]);}return$class->_acmp($x,$y)>0;},'>='=>sub{my$class=ref$_[0];
my($x,$y);
if($_[2]){$y=$_[0];
$x=ref($_[1])?$_[1]:$class->_new($_[1]);}else{$x=$class->_copy($_[0]);
$y=ref($_[1])?$_[1]:$class->_new($_[1]);}return$class->_acmp($x,$y)>=0;},'=='=>sub{my$class=ref$_[0];
my$x=$class->_copy($_[0]);
my$y=ref($_[1])?$_[1]:$class->_new($_[1]);
return$class->_acmp($x,$y)==0;},'!='=>sub{my$class=ref$_[0];
my$x=$class->_copy($_[0]);
my$y=ref($_[1])?$_[1]:$class->_new($_[1]);
return$class->_acmp($x,$y)!=0;},'<=>'=>sub{my$class=ref$_[0];
my($x,$y);
if($_[2]){$y=$_[0];
$x=ref($_[1])?$_[1]:$class->_new($_[1]);}else{$x=$class->_copy($_[0]);
$y=ref($_[1])?$_[1]:$class->_new($_[1]);}return$class->_acmp($x,$y);},'&'=>sub{my$class=ref$_[0];
my($x,$y);
if($_[2]){$y=$_[0];
$x=ref($_[1])?$_[1]:$class->_new($_[1]);}else{$x=$class->_copy($_[0]);
$y=ref($_[1])?$_[1]:$class->_new($_[1]);}return$class->_and($x,$y);},'|'=>sub{my$class=ref$_[0];
my($x,$y);
if($_[2]){$y=$_[0];
$x=ref($_[1])?$_[1]:$class->_new($_[1]);}else{$x=$class->_copy($_[0]);
$y=ref($_[1])?$_[1]:$class->_new($_[1]);}return$class->_or($x,$y);},'^'=>sub{my$class=ref$_[0];
my($x,$y);
if($_[2]){$y=$_[0];
$x=ref($_[1])?$_[1]:$class->_new($_[1]);}else{$x=$class->_copy($_[0]);
$y=ref($_[1])?$_[1]:$class->_new($_[1]);}return$class->_xor($x,$y);},'abs'=>sub{$_[0]},'sqrt'=>sub{my$class=ref$_[0];
return$class->_sqrt($class->_copy($_[0]));},'int'=>sub{$_[0]},'bool'=>sub{ref($_[0])->_is_zero($_[0])?'':1;},'""'=>sub{ref($_[0])->_str($_[0]);},'0+'=>sub{ref($_[0])->_num($_[0]);},'='=>sub{ref($_[0])->_copy($_[0]);},;
sub api_version (){croak"@{[(caller 0)[3]]} method not implemented";}sub _new{croak"@{[(caller 0)[3]]} method not implemented";}sub _zero{my$class=shift;
return$class->_new("0");}sub _one{my$class=shift;
return$class->_new("1");}sub _two{my$class=shift;
return$class->_new("2");}sub _ten{my$class=shift;
return$class->_new("10");}sub _1ex{my($class,$exp)=@_;
$exp=$class->_num($exp)if ref($exp);
return$class->_new("1".("0" x$exp));}sub _copy{my($class,$x)=@_;
return$class->_new($class->_str($x));}sub import{}sub _str{croak"@{[(caller 0)[3]]} method not implemented";}sub _num{my($class,$x)=@_;
0+$class->_str($x);}sub _add{croak"@{[(caller 0)[3]]} method not implemented";}sub _sub{croak"@{[(caller 0)[3]]} method not implemented";}sub _mul{my($class,$x,$y)=@_;
my$sum=$class->_zero();
my$i=$class->_zero();
while($class->_acmp($i,$y)<0){$sum=$class->_add($sum,$x);
$i=$class->_inc($i);}return$sum;}sub _div{my($class,$x,$y)=@_;
croak"@{[(caller 0)[3]]} requires non-zero divisor" if$class->_is_zero($y);
my$r=$class->_copy($x);
my$q=$class->_zero();
while($class->_acmp($r,$y)>=0){$q=$class->_inc($q);
$r=$class->_sub($r,$y);}return$q,$r if wantarray;
return$q;}sub _inc{my($class,$x)=@_;
$class->_add($x,$class->_one());}sub _dec{my($class,$x)=@_;
$class->_sub($x,$class->_one());}sub _acmp{my($class,$x,$y)=@_;
my$xstr=$class->_str($x);
my$ystr=$class->_str($y);
length($xstr)<=>length($ystr)||$xstr cmp$ystr;}sub _len{my($class,$x)=@_;
CORE::length($class->_str($x));}sub _alen{my($class,$x)=@_;
$class->_len($x);}sub _digit{my($class,$x,$n)=@_;
substr($class->_str($x),-($n+1),1);}sub _zeros{my($class,$x)=@_;
my$str=$class->_str($x);
$str=~/[^0](0*)\z/?CORE::length($1):0;}sub _is_zero{my($class,$x)=@_;
$class->_str($x)==0;}sub _is_even{my($class,$x)=@_;
substr($class->_str($x),-1,1)%2==0;}sub _is_odd{my($class,$x)=@_;
substr($class->_str($x),-1,1)%2!=0;}sub _is_one{my($class,$x)=@_;
$class->_str($x)==1;}sub _is_two{my($class,$x)=@_;
$class->_str($x)==2;}sub _is_ten{my($class,$x)=@_;
$class->_str($x)==10;}sub _check{my($class,$x)=@_;
return"Input is undefined" unless defined$x;
return"$x is not a reference" unless ref($x);
return 0;}sub _mod{my($class,$x,$y)=@_;
croak"@{[(caller 0)[3]]} requires non-zero second operand" if$class->_is_zero($y);
if($class->can('_div')){$x=$class->_copy($x);
my($q,$r)=$class->_div($x,$y);
return$r;}else{my$r=$class->_copy($x);
while($class->_acmp($r,$y)>=0){$r=$class->_sub($r,$y);}return$r;}}sub _rsft{my($class,$x,$n,$b)=@_;
$b=$class->_new($b)unless ref$b;
return scalar$class->_div($x,$class->_pow($class->_copy($b),$n));}sub _lsft{my($class,$x,$n,$b)=@_;
$b=$class->_new($b)unless ref$b;
return$class->_mul($x,$class->_pow($class->_copy($b),$n));}sub _pow{my($class,$x,$y)=@_;
if($class->_is_zero($y)){return$class->_one();}if(($class->_is_one($x))||($class->_is_one($y))){return$x;}if($class->_is_zero($x)){return$class->_zero();}my$pow2=$class->_one();
my$y_bin=$class->_as_bin($y);
$y_bin=~s/^0b//;
my$len=length($y_bin);
while(--$len>0){$pow2=$class->_mul($pow2,$x)if substr($y_bin,$len,1)eq '1';
$x=$class->_mul($x,$x);}$x=$class->_mul($x,$pow2);
return$x;}sub _nok{my($class,$n,$k)=@_;
{my$twok=$class->_mul($class->_two(),$class->_copy($k));
if($class->_acmp($twok,$n)>0){$k=$class->_sub($class->_copy($n),$k);}}if($class->_is_zero($k)){return$class->_one();}my$n_orig=$class->_copy($n);
$n=$class->_sub($n,$k);
$n=$class->_inc($n);
my$f=$class->_copy($n);
$f=$class->_inc($f);
my$d=$class->_two();
while($class->_acmp($f,$n_orig)<=0){$n=$class->_mul($n,$f);
$n=$class->_div($n,$d);
$f=$class->_inc($f);
$d=$class->_inc($d);}return$n;}sub _fac{my($class,$x)=@_;
my$two=$class->_two();
if($class->_acmp($x,$two)<0){return$class->_one();}my$i=$class->_copy($x);
while($class->_acmp($i,$two)>0){$i=$class->_dec($i);
$x=$class->_mul($x,$i);}return$x;}sub _dfac{my($class,$x)=@_;
my$two=$class->_two();
if($class->_acmp($x,$two)<0){return$class->_one();}my$i=$class->_copy($x);
while($class->_acmp($i,$two)>0){$i=$class->_sub($i,$two);
$x=$class->_mul($x,$i);}return$x;}sub _log_int{my($class,$x,$base)=@_;
return if$class->_is_zero($x);
$base=$class->_new(2)unless defined($base);
$base=$class->_new($base)unless ref($base);
return if$class->_is_zero($base)||$class->_is_one($base);
if($class->_is_one($x)){return$class->_zero(),1;}my$cmp=$class->_acmp($x,$base);
if($cmp==0){return$class->_one(),1;}if($cmp<0){return$class->_zero(),0;}my$y;
{my$x_str=$class->_str($x);
my$b_str=$class->_str($base);
my$xm=".".$x_str;
my$bm=".".$b_str;
my$xe=length($x_str);
my$be=length($b_str);
my$log10=log(10);
my$guess=int((log($xm)+$xe*$log10)/(log($bm)+$be*$log10));
$y=$class->_new($guess);}my$trial=$class->_pow($class->_copy($base),$y);
my$acmp=$class->_acmp($trial,$x);
return$y,1 if$acmp==0;
while($acmp<0){$trial=$class->_mul($trial,$base);
$y=$class->_inc($y);
$acmp=$class->_acmp($trial,$x);}while($acmp>0){$trial=$class->_div($trial,$base);
$y=$class->_dec($y);
$acmp=$class->_acmp($trial,$x);}return$y,1 if$acmp==0;
return$y,0;}sub _sqrt{my($class,$y)=@_;
return$y if$class->_is_zero($y);
my$y_str=$class->_str($y);
my$y_len=length($y_str);
my$xm;
my$xe;
if($y_len%2==0){$xm=sqrt(".".$y_str);
$xe=$y_len/2;
$xm=sprintf"%.0f",int($xm*1e15);
$xe-=15;}else{$xm=sqrt(".0".$y_str);
$xe=($y_len+1)/2;
$xm=sprintf"%.0f",int($xm*1e16);
$xe-=16;}my$x;
if($xe<0){$x=substr$xm,0,length($xm)+$xe;}else{$x=$xm.("0" x$xe);}$x=$class->_new($x);
my$xsq=$class->_mul($class->_copy($x),$x);
my$acmp=$class->_acmp($xsq,$y);
my$two;
$two=$class->_two()if$acmp!=0;
if($acmp<0){my$numer=$class->_sub($class->_copy($y),$xsq);
my$denom=$class->_mul($class->_copy($two),$x);
my$delta=$class->_div($numer,$denom);
unless($class->_is_zero($delta)){$x=$class->_add($x,$delta);
$xsq=$class->_mul($class->_copy($x),$x);
$acmp=$class->_acmp($xsq,$y);}}while($acmp>0){my$numer=$class->_sub($xsq,$y);
my$denom=$class->_mul($class->_copy($two),$x);
my$delta=$class->_div($numer,$denom);
last if$class->_is_zero($delta);
$x=$class->_sub($x,$delta);
$xsq=$class->_mul($class->_copy($x),$x);
$acmp=$class->_acmp($xsq,$y);}while($acmp>0){$x=$class->_dec($x);
$xsq=$class->_mul($class->_copy($x),$x);
$acmp=$class->_acmp($xsq,$y);}return$x;}sub _root{my($class,$y,$n)=@_;
return$y if$class->_is_zero($y)||$class->_is_one($y)||$class->_is_one($n);
return$class->_one()if$class->_acmp($y,$n)<=0;
my$DEBUG=0;
my$y_str=$class->_str($y);
my$ym=".".$y_str;
my$ye=length($y_str);
my$log10y=log($ym)/log(10)+$ye;
my$log10x=$log10y/$class->_num($n);
my$xe=int$log10x;
my$xm=10**($log10x-$xe);
if($DEBUG){print"\n";
print"y_str  = $y_str\n";
print"ym     = $ym\n";
print"ye     = $ye\n";
print"log10y = $log10y\n";
print"log10x = $log10x\n";
print"xm     = $xm\n";
print"xe     = $xe\n";}my$d=$xe<15?$xe:15;
$xm*=10**$d;
$xe-=$d;
if($DEBUG){print"\n";
print"xm     = $xm\n";
print"xe     = $xe\n";}my$xm_int=int($xm);
my$x_str=sprintf '%.0f',$xm>$xm_int?$xm_int+1:$xm_int;
$x_str.="0" x$xe;
my$x=$class->_new($x_str);
if($DEBUG){print"xm     = $xm\n";
print"xe     = $xe\n";
print"\n";
print"x_str  = $x_str (initial guess)\n";
print"\n";}my$nm1=$class->_dec($class->_copy($n));
my$xpownm1=$class->_pow($class->_copy($x),$nm1);
my$xpown=$class->_mul($class->_copy($xpownm1),$x);
my$acmp=$class->_acmp($xpown,$y);
if($DEBUG){print"\n";
print"x      = ",$class->_str($x),"\n";
print"x^n    = ",$class->_str($xpown),"\n";
print"y      = ",$class->_str($y),"\n";
print"acmp   = $acmp\n";}if($acmp<0){my$numer=$class->_sub($class->_copy($y),$xpown);
my$denom=$class->_mul($class->_copy($n),$xpownm1);
my$delta=$class->_div($numer,$denom);
if($DEBUG){print"\n";
print"numer  = ",$class->_str($numer),"\n";
print"denom  = ",$class->_str($denom),"\n";
print"delta  = ",$class->_str($delta),"\n";}unless($class->_is_zero($delta)){$x=$class->_add($x,$delta);
$xpownm1=$class->_pow($class->_copy($x),$nm1);
$xpown=$class->_mul($class->_copy($xpownm1),$x);
$acmp=$class->_acmp($xpown,$y);
if($DEBUG){print"\n";
print"x      = ",$class->_str($x),"\n";
print"x^n    = ",$class->_str($xpown),"\n";
print"y      = ",$class->_str($y),"\n";
print"acmp   = $acmp\n";}}}while($acmp>0){my$numer=$class->_sub($class->_copy($xpown),$y);
my$denom=$class->_mul($class->_copy($n),$xpownm1);
if($DEBUG){print"numer  = ",$class->_str($numer),"\n";
print"denom  = ",$class->_str($denom),"\n";}my$delta=$class->_div($numer,$denom);
if($DEBUG){print"delta  = ",$class->_str($delta),"\n";}last if$class->_is_zero($delta);
$x=$class->_sub($x,$delta);
$xpownm1=$class->_pow($class->_copy($x),$nm1);
$xpown=$class->_mul($class->_copy($xpownm1),$x);
$acmp=$class->_acmp($xpown,$y);
if($DEBUG){print"\n";
print"x      = ",$class->_str($x),"\n";
print"x^n    = ",$class->_str($xpown),"\n";
print"y      = ",$class->_str($y),"\n";
print"acmp   = $acmp\n";}}while($acmp>0){$x=$class->_dec($x);
$xpown=$class->_pow($class->_copy($x),$n);
$acmp=$class->_acmp($xpown,$y);}return$x;}sub _and{my($class,$x,$y)=@_;
return$x if$class->_acmp($x,$y)==0;
my$m=$class->_one();
my$mask=$class->_new("32768");
my($xr,$yr);
my$xc=$class->_copy($x);
my$yc=$class->_copy($y);
my$z=$class->_zero();
until($class->_is_zero($xc)||$class->_is_zero($yc)){($xc,$xr)=$class->_div($xc,$mask);
($yc,$yr)=$class->_div($yc,$mask);
my$bits=$class->_new($class->_num($xr)&$class->_num($yr));
$z=$class->_add($z,$class->_mul($bits,$m));
$m=$class->_mul($m,$mask);}return$z;}sub _xor{my($class,$x,$y)=@_;
return$class->_zero()if$class->_acmp($x,$y)==0;
my$m=$class->_one();
my$mask=$class->_new("32768");
my($xr,$yr);
my$xc=$class->_copy($x);
my$yc=$class->_copy($y);
my$z=$class->_zero();
until($class->_is_zero($xc)||$class->_is_zero($yc)){($xc,$xr)=$class->_div($xc,$mask);
($yc,$yr)=$class->_div($yc,$mask);
my$bits=$class->_new($class->_num($xr)^$class->_num($yr));
$z=$class->_add($z,$class->_mul($bits,$m));
$m=$class->_mul($m,$mask);}$z=$class->_add($z,$class->_mul($xc,$m))unless$class->_is_zero($xc);
$z=$class->_add($z,$class->_mul($yc,$m))unless$class->_is_zero($yc);
return$z;}sub _or{my($class,$x,$y)=@_;
return$x if$class->_acmp($x,$y)==0;
my$m=$class->_one();
my$mask=$class->_new("32768");
my($xr,$yr);
my$xc=$class->_copy($x);
my$yc=$class->_copy($y);
my$z=$class->_zero();
until($class->_is_zero($xc)||$class->_is_zero($yc)){($xc,$xr)=$class->_div($xc,$mask);
($yc,$yr)=$class->_div($yc,$mask);
my$bits=$class->_new($class->_num($xr)|$class->_num($yr));
$z=$class->_add($z,$class->_mul($bits,$m));
$m=$class->_mul($m,$mask);}$z=$class->_add($z,$class->_mul($xc,$m))unless$class->_is_zero($xc);
$z=$class->_add($z,$class->_mul($yc,$m))unless$class->_is_zero($yc);
return$z;}sub _to_bin{my($class,$x)=@_;
my$str='';
my$tmp=$class->_copy($x);
my$chunk=$class->_new("16777216");
my$rem;
until($class->_acmp($tmp,$chunk)<0){($tmp,$rem)=$class->_div($tmp,$chunk);
$str=sprintf("%024b",$class->_num($rem)).$str;}unless($class->_is_zero($tmp)){$str=sprintf("%b",$class->_num($tmp)).$str;}return length($str)?$str:'0';}sub _to_oct{my($class,$x)=@_;
my$str='';
my$tmp=$class->_copy($x);
my$chunk=$class->_new("16777216");
my$rem;
until($class->_acmp($tmp,$chunk)<0){($tmp,$rem)=$class->_div($tmp,$chunk);
$str=sprintf("%08o",$class->_num($rem)).$str;}unless($class->_is_zero($tmp)){$str=sprintf("%o",$class->_num($tmp)).$str;}return length($str)?$str:'0';}sub _to_hex{my($class,$x)=@_;
my$str='';
my$tmp=$class->_copy($x);
my$chunk=$class->_new("16777216");
my$rem;
until($class->_acmp($tmp,$chunk)<0){($tmp,$rem)=$class->_div($tmp,$chunk);
$str=sprintf("%06x",$class->_num($rem)).$str;}unless($class->_is_zero($tmp)){$str=sprintf("%x",$class->_num($tmp)).$str;}return length($str)?$str:'0';}sub _as_bin{my($class,$x)=@_;
return '0b'.$class->_to_bin($x);}sub _as_oct{my($class,$x)=@_;
return '0'.$class->_to_oct($x);}sub _as_hex{my($class,$x)=@_;
return '0x'.$class->_to_hex($x);}sub _to_bytes{my($class,$x)=@_;
my$str='';
my$tmp=$class->_copy($x);
my$chunk=$class->_new("65536");
my$rem;
until($class->_is_zero($tmp)){($tmp,$rem)=$class->_div($tmp,$chunk);
$str=pack('n',$class->_num($rem)).$str;}$str=~s/^\0+//;
return length($str)?$str:"\x00";}*_as_bytes=\&_to_bytes;
sub _from_hex{my($class,$hex)=@_;
$hex=~s/^0[xX]//;
my$len=length$hex;
my$rem=1+($len-1)%7;
my$ret=$class->_new(int hex substr$hex,0,$rem);
return$ret if$rem==$len;
my$shift=$class->_new(1 <<(4*7));
for(my$offset=$rem;$offset<$len;$offset+=7){my$part=int hex substr$hex,$offset,7;
$ret=$class->_mul($ret,$shift);
$ret=$class->_add($ret,$class->_new($part));}return$ret;}sub _from_oct{my($class,$oct)=@_;
my$len=length$oct;
my$rem=1+($len-1)%10;
my$ret=$class->_new(int oct substr$oct,0,$rem);
return$ret if$rem==$len;
my$shift=$class->_new(1 <<(3*10));
for(my$offset=$rem;$offset<$len;$offset+=10){my$part=int oct substr$oct,$offset,10;
$ret=$class->_mul($ret,$shift);
$ret=$class->_add($ret,$class->_new($part));}return$ret;}sub _from_bin{my($class,$bin)=@_;
$bin=~s/^0[bB]//;
my$len=length$bin;
my$rem=1+($len-1)%31;
my$ret=$class->_new(int oct '0b'.substr$bin,0,$rem);
return$ret if$rem==$len;
my$shift=$class->_new(1 <<31);
for(my$offset=$rem;$offset<$len;$offset+=31){my$part=int oct '0b'.substr$bin,$offset,31;
$ret=$class->_mul($ret,$shift);
$ret=$class->_add($ret,$class->_new($part));}return$ret;}sub _from_bytes{my($class,$str)=@_;
my$x=$class->_zero();
my$base=$class->_new("256");
my$n=length($str);
for(my$i=0;$i<$n;++$i){$x=$class->_mul($x,$base);
my$byteval=$class->_new(unpack 'C',substr($str,$i,1));
$x=$class->_add($x,$byteval);}return$x;}sub _modinv{my($class,$x,$y)=@_;
if($class->_is_zero($y)){return(undef,undef);}if($class->_is_one($y)){return($class->_zero(),'+');}my$u=$class->_zero();
my$v=$class->_one();
my$a=$class->_copy($y);
my$b=$class->_copy($x);
my$q;
my$sign=1;
{($a,$q,$b)=($b,$class->_div($a,$b));
last if$class->_is_zero($b);
my$vq=$class->_mul($class->_copy($v),$q);
my$t=$class->_add($vq,$u);
$u=$v;
$v=$t;
$sign=-$sign;
redo;}return(undef,undef)unless$class->_is_one($a);
($v,$sign==1?'+':'-');}sub _modpow{my($class,$num,$exp,$mod)=@_;
if($class->_is_one($mod)){return$class->_zero();}if($class->_is_zero($num)){return$class->_is_zero($exp)?$class->_one():$class->_zero();}my$acc=$class->_copy($num);
my$t=$class->_one();
my$expbin=$class->_as_bin($exp);
$expbin=~s/^0b//;
my$len=length($expbin);
while(--$len>=0){if(substr($expbin,$len,1)eq '1'){$t=$class->_mul($t,$acc);
$t=$class->_mod($t,$mod);}$acc=$class->_mul($acc,$acc);
$acc=$class->_mod($acc,$mod);}return$t;}sub _gcd{my($class,$x,$y)=@_;
if($class->_acmp($x,$y)==0){return$class->_copy($x);}if($class->_is_zero($x)){if($class->_is_zero($y)){return$class->_zero();}else{return$class->_copy($y);}}else{if($class->_is_zero($y)){return$class->_copy($x);}else{$x=$class->_copy($x);
until($class->_is_zero($y)){$x=$class->_mod($x,$y);
my$tmp=$x;
$x=$class->_copy($y);
$y=$tmp;}return$x;}}}sub _lcm{my($class,$x,$y)=@_;
return$class->_zero()if($class->_is_zero($x)||$class->_is_zero($y));
my$gcd=$class->_gcd($class->_copy($x),$y);
$x=$class->_div($x,$gcd);
$x=$class->_mul($x,$y);
return$x;}sub _lucas{my($class,$n)=@_;
$n=$class->_num($n)if ref$n;
if(wantarray){my@y;
push@y,$class->_two();
return@y if$n==0;
push@y,$class->_one();
return@y if$n==1;
for(my$i=2;$i<=$n;++$i){$y[$i]=$class->_add($class->_copy($y[$i-1]),$y[$i-2]);}return@y;}require Scalar::Util;
return$class->_two()if$n==0;
return$class->_add(scalar$class->_fib($n-1),scalar$class->_fib($n+1));}sub _fib{my($class,$n)=@_;
$n=$class->_num($n)if ref$n;
if(wantarray){my@y;
push@y,$class->_zero();
return@y if$n==0;
push@y,$class->_one();
return@y if$n==1;
for(my$i=2;$i<=$n;++$i){$y[$i]=$class->_add($class->_copy($y[$i-1]),$y[$i-2]);}return@y;}my$cache={};
my$two=$class->_two();
my$fib;
$fib=sub{my$n=shift;
return$class->_zero()if$n<=0;
return$class->_one()if$n<=2;
return$cache->{$n}if exists$cache->{$n};
my$k=int($n/2);
my$a=$fib->($k+1);
my$b=$fib->($k);
my$y;
if($n%2==1){$y=$class->_add($class->_mul($class->_copy($a),$a),$class->_mul($class->_copy($b),$b));}else{$y=$class->_mul($class->_sub($class->_mul($class->_copy($two),$a),$b),$b);}$cache->{$n}=$y;
return$y;};
return$fib->($n);}1;
